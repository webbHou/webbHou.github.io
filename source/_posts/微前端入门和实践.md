---
title: 微前端入门和实践
tags:
  - javascript
categories: js常见问题
date: 2022-11-02 17:45:34
---

##  什么是微前端？

微前端是一种多个团队通过独立发布功能的方式来共同构建现代化 web 应用的技术手段及方法策略。微前端借鉴了微服务的架构理念，将一个庞大的前端应用拆分为多个独立灵活的小型应用，每个应用都可以独立开发、独立运行、独立部署，再将这些小型应用联合为一个完整的应用。微前端既可以将多个项目融合为一，又可以减少项目之间的耦合，提升项目扩展性，相比一整块的前端仓库，微前端架构下的前端仓库倾向于更小更灵活。
## 微前端的特性？

1 技术栈无关 主框架不限制接入应用的技术栈，子应用可自主选择技术栈

2 独立开发/部署 各个团队之间仓库独立，单独部署，互不依赖

3 增量升级 当一个应用庞大之后，技术升级或重构相当麻烦，而微应用具备渐进式升级的特性

4 独立运行时 微应用之间运行时互不依赖，有独立的状态管理

5 提升效率 应用越庞大，越难以维护，协作效率越低下。微应用可以很好拆分，提升效率

## 如何实现微前端？

微前端的方案目前有以下几种类型：基于 iframe 完全隔离的方案，基于 single-spa 路由劫持方案，京东 micro-app 方案，阿里的qiankun框架。我们的店长后台admin基于qiankun实现，以下将介绍qiankun用法。https://qiankun.umijs.org/zh/guide (qiankun官网地址)
### qiankun 的核心设计理念
1 简单

由于主应用微应用都能做到技术栈无关，qiankun 对于用户而言只是一个类似 jQuery 的库，你需要调用几个 qiankun 的 API 即可完成应用的微前端改造。同时由于 qiankun 的 HTML entry 及沙箱的设计，使得微应用的接入像使用 iframe 一样简单。

2 解耦/技术栈无关

微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，而 qiankun 的诸多设计均是秉持这一原则，如 HTML entry、沙箱、应用间通信等。这样才能确保微应用真正具备 独立开发、独立运行 的能力。

### qiankun特性

1 基于 single-spa 封装，提供了更加开箱即用的 API。

2 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。

3 HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单。

4 样式隔离，确保微应用之间样式互相不干扰。

5 JS 沙箱，确保微应用之间 全局变量/事件 不冲突。

6 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。

7 umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统。

### 快速使用qiankun？

### API

#### 基于路由配置api

#### 1.registerMicroApps

注册微应用的基础配置信息。当浏览器 url 发生变化时，会自动检查每一个微应用注册的 activeRule 规则，符合规则的应用将会被自动激活。

registerMicroApps(apps(Array<RegistrableApp> - 必选，微应用的一些注册信息), lifeCycles? (可选，全局的微应用生命周期钩子))

#### 2.start

启动 qiankun。

start(opts? (Options 可选))

#### 3.setDefaultMountApp(appLink(string - 必选))

设置主应用启动后默认进入的微应用。

#### 4.runAfterFirstMounted(effect (() => void - 必选))

第一个微应用 mount 后需要调用的方法，比如开启一些监控或者埋点脚本。

#### 手动加载微应用 

第一个微应用 mount 后需要调用的方法，比如开启一些监控或者埋点脚本。注意：通常这种场景下微应用是一个不带路由的可独立运行的业务组件。 微应用不宜拆分过细，建议按照业务域来做拆分。业务关联紧密的功能单元应该做成一个微应用，反之关联不紧密的可以考虑拆分成多个微应用。 一个判断业务关联是否紧密的标准：看这个微应用与其他微应用是否有频繁的通信需求。如果有可能说明这两个微应用本身就是服务于同一个业务场景，合并成一个微应用可能会更合适。

#### 5.loadMicroApp(app （必选，微应用的基础信息）, configuration?（可选，微应用的配置信息）)

返回值 - MicroApp - 微应用实例

手动加载一个微应用。

如果需要能支持主应用手动 update 微应用，需要微应用 entry 再多导出一个 update 钩子：
```language
export async function mount(props) {
  renderApp(props);
}

// 增加 update 钩子以便主应用手动更新微应用
export async function update(props) {
  renderPatch(props);
}
```
### 6.prefetchApps(apps （必选 - 预加载的应用列表）, importEntryOpts? （可选 - 加载配置）)

手动预加载指定的微应用静态资源。仅手动加载微应用场景需要，基于路由自动激活场景直接配置 prefetch 属性即可。

#### 7.addErrorHandler/removeErrorHandler

addGlobalUncaughtErrorHandler(handler (...args: any[]) => void - 必选）)

添加全局的未捕获异常处理器。

removeGlobalUncaughtErrorHandler(handler （(...args: any[]) => void - 必选）)

移除全局的未捕获异常处理器。

#### 8.initGlobalState(state (Record<string, any> - 必选))

定义全局状态，并返回通信方法，建议在主应用使用，微应用通过 props 获取通信方法。

e.g

主应用：

```language
import { initGlobalState, MicroAppStateActions } from 'qiankun';

// 初始化 state
const actions: MicroAppStateActions = initGlobalState(state);

actions.onGlobalStateChange((state, prev) => {
  // state: 变更后的状态; prev 变更前的状态
  console.log(state, prev);
});
actions.setGlobalState(state);
actions.offGlobalStateChange();

```
微应用：
```language
// 从生命周期 mount 中获取通信方法，使用方式和 master 一致
export function mount(props) {
  props.onGlobalStateChange((state, prev) => {
    // state: 变更后的状态; prev 变更前的状态
    console.log(state, prev);
  });

  props.setGlobalState(state);
}

```

### 主应用
e.g:
1. 安装 qiankun 

```language
  $ yarn add qiankun # 或者 npm i qiankun -S

```
2. 在主应用中注册微应用

```language
const apps = [
    {
        name: 'adminApp',
        entry: isProduction ? '/web/childrens/admin/' : '//localhost:7001/html/',
        container: '#manage-view',
        activeRule: '/web/admin/',
        props: { BrowserHistory },
        loader: (loading) => {
            window.globalLoadingStatus = loading
        }
   ]
  import { registerMicroApps, start } from 'qiankun'
  export const registerApp = () => {
    console.log('启动qiankun')
    registerMicroApps(apps)
  }
 export default start
```
当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑，所有 activeRule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子。如果微应用不是直接跟路由关联的时候，你也可以选择手动加载微应用的方式：
```language
import { loadMicroApp } from 'qiankun';
   loadMicroApp({
       name: 'app',
       entry: '//localhost:7100',
      container: '#yourContainer',
});
```

### 微应用
微应用不需要额外安装任何其他依赖即可接入 qiankun 主应用。
1. 导出相应的生命周期钩子

微应用需要在自己的入口 js (通常就是你配置的 webpack 的 entry js) 导出 bootstrap、mount、unmount 三个生命周期钩子，以供主应用在适当的时机调用。
```language
/**
 * bootstrap 只会在微应用初始化的时候调用一次，下次微应用重新进入时会直接调用 mount 钩子，不会再重复触发 bootstrap。
 * 通常我们可以在这里做一些全局变量的初始化，比如不会在 unmount 阶段被销毁的应用级别的缓存等。
 */
export async function bootstrap() {
  console.log('react app bootstraped');
}

/**
 * 应用每次进入都会调用 mount 方法，通常我们在这里触发应用的渲染方法
 */
export async function mount(props) {
  ReactDOM.render(<App />, props.container ? props.container.querySelector('#root') : document.getElementById('root'));
}

/**
 * 应用每次 切出/卸载 会调用的方法，通常在这里我们会卸载微应用的应用实例
 */
export async function unmount(props) {
  ReactDOM.unmountComponentAtNode(
    props.container ? props.container.querySelector('#root') : document.getElementById('root'),
  );
}

/**
 * 可选生命周期钩子，仅使用 loadMicroApp 方式加载微应用时生效
 */
export async function update(props) {
  console.log('update props', props);
}

```
2. 配置微应用的打包工具

webpack:
```language
const packageName = require('./package.json').name;

module.exports = {
  output: {
    library: `${packageName}-[name]`,
    libraryTarget: 'umd',
    jsonpFunction: `webpackJsonp_${packageName}`,
  },
};

```
