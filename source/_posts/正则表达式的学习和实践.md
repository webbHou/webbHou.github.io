---
title: 正则表达式的学习和实践
tags:
  - javascript
  - 正则
categories: 前端知识
date: 2020-11-24 11:15:12
---


#### 基本规则

| single char(单字符) | quantifiers(数量) | position(位置) | flag |
| ---- | ---- | ---- | ---- |
| \d 匹配数字 | * 0个或多个 | ^匹配一行的开头 | g全局匹配 |
| \w 匹配字母数字 | + 1个或多个 至少一个 | $匹配一行的结尾 | i忽略大小写 |
| \W 匹配非数字字母 | ? 匹配0个或1个 | \b单词结界 | m多行匹配 |
| \s 匹配空格 | {min,max} 出现次数在范围内的 | - | - |
| \S 匹配非空格 | {n} 出现n次的 | - | - |
| . 匹配任意字符 | - | - | - |

##### 字符分类[]

- 用来表示逻辑关系或，[abc]表示匹配a或b或c
- 字符分类里边的特殊字符不需要转义 [.()]
- 当连字符不是第一个字符时 [a-z] 表示匹配从a到z的任意字符
- ^在字符分类里表示取反 [^ab] 表示匹配非a非b的任意字符
- ()也可以表示逻辑或 (a|b|c)

##### 分组捕获()

- 每一个()都是一个组 0代表整个匹配项 分组编号从1开始
- 在进行匹配后的操作时可以通过$1 $2拿到匹配到的分组 $0表示整个字符串

```javascript
//把手机号变成通用的 只保留区号
let reg = /(\d{3})[.-](\d{3})[.-](\d{4})/

'212-555-1234'.replace(reg,'$1-xxx-xxxx');

//交换单词
'shiffina, Daniel'.replace(/(\w+),\s(\w+)/,'$2, $1')
```

- 如果在正则里边就拿到匹配的分组 可以通过分组编号拿到

```javascript
var reg = /\b(\w+)\s\1\b/; //匹配连续的相同的单词

'this is is age'.replace(reg,'$1') //this is age
```

- 贪婪的*，如果使用*去匹配 会一直匹配到最后一个

```javascript
let reg = /\[.*\]/;
'[baidu]http://www.baodu.com [google]'.replace(reg,'<h1></h1>') //<h1></h1>

//*后边?去掉贪婪模式
let reg2 = /\[.*?\]/;
'[baidu]http://www.baodu.com [google]'.replace(reg2,'<h1></h1>') //<h1></h1>http://www.baodu.com [google]
```

##### 正则在js中的应用

- reg.test 返回boolean 测试是不是通过正则规则
- str.match 返回匹配到的内容 默认返回第一个 有分组的话数组的第二个元素起就是匹配到的分组
- reg.exec(str) 每次调用，返回一个匹配的结果 匹配结果和分组以数组的形式返回

```javascript
var str = "Here is a Phone Number 111-2313 and 133-2311" ;
var srg = /(\d{3})[-.]\d{4}/g;
var result = srg.exec(str);
while(result !== null) {
    console.log(result);
    result = srg.exec(str);
}
```

- str.split(str|reg) 按匹配项分割字符串

```javascript
var reg = /[,.?!\s]+/  //按单词分割
var reg = /([,.?!]+)/ //按句子分割并保留分割符
```

- str.replace(reg,str|fn) 查找替换 返回替换后的值

```javascript
var reg = /<\/?.+?\/?>/g //匹配所有html标签 支持嵌套
```

```javascript
//找出出现次数最多的字符
var str = 'aabbsbaabbabaslld';
var a =  str.split('').sort().join('');
var max = 0;
var char = '';
a.replace(/(\w)\1+/g,function(match,$1){  
  if(max<match.length){
    max = match.length;
    char = match[0];
  }
  return match
})

//or

var arr = a.replace(/(\w)\1+/g);
arr.sort(function(a,b){
  return b.length - a.length
})
max = arr[0].length;
char = arr[0][0];
```
