<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <title>
        大圣博客
    </title>
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="大圣博客" type="application/atom+xml">
</head>

<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"
        ><i class="fa fa-reply replay-btn" aria-hidden="true"></i
    ></a>
    <div class="post-title">
        <p>面试秘籍-原生js篇</p>
        <hr />
        
        <div class="category">
            page.categories 
            <a href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
            
        </div>
         
        <div class="category">
            page.tags 
            <a href="/tags/javascript/">javascript</a>
            
        </div>
        
    </div>
    <div class="post-content"><h4 id="获取元素位置和大小的方法和区别"><a href="#获取元素位置和大小的方法和区别" class="headerlink" title="获取元素位置和大小的方法和区别"></a>获取元素位置和大小的方法和区别</h4><ul>
<li><p>offset</p>
<ul>
<li>offsetTop：获取元素顶部距离定位父级的距离 元素外边框至定位父级上内边框的距离。外边距+父级上内边距</li>
<li>offsetLeft：获取元素左边距离定位父级的距离 元素外边框至定位父级左内边框的距离。外边距+父级左内边距</li>
<li>offsetWidth&#x2F;offsetHeight：获取元素在页面上可见的空间大小，不包含隐藏滚动区域 实际宽度 + 左右内边距 + 左右边框</li>
</ul>
</li>
<li><p>client</p>
<ul>
<li>clientLeft&#x2F;clientTop：实际获取的就是元素的边框宽度</li>
<li>clientWidth&#x2F;clientHeight：获取元素内容和内边距占的大小 不包含隐藏滚动区域 内容区域+内边距-滚动条宽度</li>
</ul>
</li>
<li><p>scroll</p>
<ul>
<li>scrollLeft 和 scrollTop：获取当前元素的滚动位置 隐藏在内容区域左侧和上方的像素</li>
<li>scrollWidth 和 scrollHeight：获取包含滚动内容的元素的大小</li>
</ul>
</li>
<li><p>getBoundClientRect：</p>
<ul>
<li>top&#x2F;bottom：顶部&#x2F;底部距离视口上边的距离 height &#x3D; bottom - top</li>
<li>left&#x2F;bottom：左侧&#x2F;右侧距离视口左边的距离 width &#x3D; right - left</li>
</ul>
</li>
<li><p>getComputedStyle：获取元素样式</p>
<ul>
<li>width&#x2F;height: 实际宽高 不包含内外边距和边框</li>
</ul>
</li>
</ul>
<h5 id="如何获取元素到文档顶部的距离"><a href="#如何获取元素到文档顶部的距离" class="headerlink" title="如何获取元素到文档顶部的距离"></a>如何获取元素到文档顶部的距离</h5><p>1.offsetTop</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getTop</span>(<span class="params">ele</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> top = ele.<span class="property">offsetTop</span>;</span><br><span class="line">    <span class="keyword">var</span> parent = ele.<span class="property">offsetParent</span>;</span><br><span class="line">    <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">        top += parent.<span class="property">offsetTop</span>;</span><br><span class="line">        parent = parent.<span class="property">offsetParent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.getBoundingClientRect().top + offsetParent.scrollTop</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getTop</span>(<span class="params">ele</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> top = ele.<span class="title function_">getBoundingClientRect</span>().<span class="property">top</span>;</span><br><span class="line">    <span class="keyword">var</span> parent = ele.<span class="property">offsetParent</span>;</span><br><span class="line">    <span class="keyword">while</span> (parent) &#123;</span><br><span class="line">        top += parent.<span class="property">scrollTop</span>;</span><br><span class="line">        parent = parent.<span class="property">offsetParent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="判断一个元素是不是包含另一个元素"><a href="#判断一个元素是不是包含另一个元素" class="headerlink" title="判断一个元素是不是包含另一个元素"></a>判断一个元素是不是包含另一个元素</h5><p>parentele.contains(ele)</p>
<h3 id="原型-构造函数-实例"><a href="#原型-构造函数-实例" class="headerlink" title="原型&#x2F;构造函数&#x2F;实例"></a>原型&#x2F;构造函数&#x2F;实例</h3><ul>
<li>原型(prototype)：包含实例的构造函数和原型方法的对象，用于实现实例的属性继承。可以理解成对象的爹，每个 JavaScript 对象中都包含一个<strong>proto</strong> (非标准)的属性指向它爹(该对象的原型)，可 obj.<strong>proto</strong>进行访问。</li>
<li>构造函数：可以通过 new 来 新建一个对象 的函数，每个函数都可以是构造函数。一般构造函数的首字母大写 构造函数的 prototype 也指向原型 构造函数的<em>proto</em>指向函数原型。</li>
<li>实例：通过构造函数 new 出来的对象 实例的<em>proto</em>指向原型 实例的 constructor 指向构造函数 构造函数的 prototype 也指向原型 原型的 constructor 只想构造函数</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链由原型对象组成，每个对象都有<em>proto</em>属性，指向创建该对象的构造函数的原型，<em>proto</em>属性把对象链接组成原型链，是一个用来实现继承和共享属性的有限的对象链。</p>
<ul>
<li>属性查找机制：当查找对象的属性时，如果实例上不存在该对象，则沿着原型链往上一级查找，找到则输出否则继续往上一级查找，直到顶级原型对象 Object.prototype，没有则返回 undefined</li>
<li>属性修改机制：只会修改该实例的属性，没有则添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x &#x3D; 2；但是这样会造成所有继承于该对象的实例的属性发生改变。</li>
</ul>
<h3 id="修改-vue-router-原型调用"><a href="#修改-vue-router-原型调用" class="headerlink" title="修改 vue-router 原型调用"></a>修改 vue-router 原型调用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> history = &#123; ...router.<span class="property">history</span>, <span class="attr">base</span>: <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">history.<span class="property">__proto__</span> = router.<span class="property">history</span>.<span class="property">__proto__</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(router.<span class="property">history</span>.<span class="property">__proto__</span>, router.<span class="property">__proto__</span>, router.<span class="property">history</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">[<span class="string">&quot;push&quot;</span>, <span class="string">&quot;replace&quot;</span>].<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>[item + <span class="string">&quot;Global&quot;</span>] = <span class="title class_">VueRouter</span>.<span class="property"><span class="keyword">prototype</span></span>[item].<span class="title function_">bind</span>(&#123;</span><br><span class="line">        history,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域其实可理解为该上下文中<em>声明的变量和声明的作用范围</em>。可分为<em>块级作用域</em> 和 <em>函数作用域</em>。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>声明提前: 一个声明在函数体内都是可见的, 函数优先于变量</li>
<li>非匿名自执行函数，函数变量为 只读 状态，无法修改</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const foo = 1</span><br><span class="line">(<span class="keyword">function</span> <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    foo = 10  // 由于foo在函数中只为可读，因此赋值无效</span><br><span class="line">    console.log(foo)</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">// 结果打印：  ƒ <span class="function"><span class="title">foo</span></span>() &#123; foo = 10 ; console.log(foo) &#125;</span><br></pre></td></tr></table></figure>

<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>作用域链可以理解为一组对象列表，包含<em>父级和自身的变量对象</em>，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包：当函数 A 被摧毁的情况下，返回出的子函数中依然保存着父级的变量和作用域，因此可以访问父函数的变量对象，这样的函数叫做闭包。<br>应用：函数柯里化、第三方库(避免全局污染)</p>
<h4 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i=0;i&lt;6;i++)&#123;</span><br><span class="line">  setTimeOUt(()=&gt;&#123;</span><br><span class="line">    console.log(i)  //setTimeOut是异步函数会在循环结束后执行 这时所以i是<span class="number">6</span></span><br><span class="line">  &#125;,i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决办法-1-闭包"><a href="#解决办法-1-闭包" class="headerlink" title="解决办法 1 闭包"></a>解决办法 1 闭包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(var i=0;i&lt;6;i++)&#123;</span><br><span class="line">  (<span class="keyword">function</span>(j) &#123;</span><br><span class="line">    setTimeOUt(()=&gt;&#123;</span><br><span class="line">      console.log(j)</span><br><span class="line">    &#125;,j*<span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决办法-2-setTimeout-第三个参数"><a href="#解决办法-2-setTimeout-第三个参数" class="headerlink" title="解决办法 2 setTimeout 第三个参数"></a>解决办法 2 setTimeout 第三个参数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(</span><br><span class="line">        <span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">        &#125;,</span><br><span class="line">        i * <span class="number">1000</span>,</span><br><span class="line">        i</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决办法-2-let-创建块级作用域"><a href="#解决办法-2-let-创建块级作用域" class="headerlink" title="解决办法 2 let 创建块级作用域"></a>解决办法 2 let 创建块级作用域</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;, i * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="script-引入方式"><a href="#script-引入方式" class="headerlink" title="script 引入方式"></a>script 引入方式</h3><ul>
<li>script 标签静态引入 遇到标签加载并执行</li>
<li>js 动态插入</li>
<li>script async 与后面元素并行（加载并执行，加载完就执行，并不按声明顺序）</li>
<li>script defer 与后面元素并行 (加载但不执行，等所以元素解析完后执行，DOMContentLoaded 事件触发前执行，按声明顺序执行)</li>
</ul>
<h3 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h3><h4 id="浅拷贝-只会拷贝第一层，深层的修改依然会有影响"><a href="#浅拷贝-只会拷贝第一层，深层的修改依然会有影响" class="headerlink" title="浅拷贝: 只会拷贝第一层，深层的修改依然会有影响"></a>浅拷贝: 只会拷贝第一层，深层的修改依然会有影响</h4><ul>
<li>Object.assign({},obj);</li>
<li>…展开符</li>
</ul>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><ul>
<li>JSON.parse(JSON.stringify(obj)): 性能最快 （值为函数或 undefined 时，无法拷贝）</li>
<li>递归</li>
</ul>
<h3 id="new-运算符的执行过程"><a href="#new-运算符的执行过程" class="headerlink" title="new 运算符的执行过程"></a>new 运算符的执行过程</h3><ul>
<li>新生成一个对象</li>
<li>新对象的<em>proto</em>指向构造函数的 prototype</li>
<li>绑定 this 并执行构造函数</li>
<li>返回该对象</li>
</ul>
<h3 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">Anmail</span></span>()&#123;</span><br><span class="line">  this.specil = <span class="string">&#x27;动物‘</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>父对象构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行：</li>
</ul>
<p>缺点：</p>
<ul>
<li>只能继承属性，不能继承原型方法</li>
<li>无法实现复用，每个子类都有父类实例函数的副本，影响性能</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="title class_">Anmail</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;大毛&quot;</span>, <span class="string">&quot;黄色&quot;</span>);</span><br><span class="line"><span class="title function_">alert</span>(cat1.<span class="property">species</span>); <span class="comment">// 动物</span></span><br></pre></td></tr></table></figure>

<ul>
<li>修改 prototype 指向：把子对象的 prototype 指向父对象的实例，则有了父对象的属性，但只能为静态</li>
</ul>
<p>缺点：<strong>(实例对引用类型的修改会影响原数据)</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Anmail</span>();</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Cat</span>; <span class="comment">//最后把子对象构造函数指向本身</span></span><br></pre></td></tr></table></figure>

<ul>
<li>直接继承 prototype：把子对象的 prototype 指向父对象的 prototype</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Cat</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Anmail</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Cat</span>; <span class="comment">//会修改Anmail对象的构造函数指向</span></span><br></pre></td></tr></table></figure>

<ul>
<li>利用空对象作为中介:对直接继承的修改</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Anmail</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Cat</span>;</span><br><span class="line"><span class="title class_">Cat</span>.<span class="property">uber</span> = <span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">//为了实现继承的完备性 指向父级的prototype</span></span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>(<span class="params">parent,child</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> p = parent.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">var</span> c = parent.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> p)&#123;</span><br><span class="line">    c[i] = p[i]</span><br><span class="line">  &#125;</span><br><span class="line">  c.<span class="property">uber</span> = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Es6 class 继承</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Anmail</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><ul>
<li>除+以外的运算都先转为数值</li>
<li>+有一端为字符串则都转完字符串 否则为数值</li>
<li>[1].toString &#x3D;&#x3D;&#x3D; ‘1’ 先转为数值再转为字符串</li>
<li>var a &#x3D; {} a.toString() &#x3D;&#x3D;&#x3D; ‘[object object]’</li>
</ul>
<h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><ul>
<li><p>Object.prototype.toString.call(obj): 原理：调用 Object 的原型的 toString 方法（返回对象的具体类型）</p>
</li>
<li><p>typeof：是对对象的二进制进行区分的 因为不同对象的在底层表示为二进制的不同 这也是为什么 typeof null&#x3D;&#x3D;&#x3D;‘object’的原因</p>
</li>
<li><p>instance：是在该对象的原型链上进行查找是否有与之匹配的原型对象</p>
</li>
</ul>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><ul>
<li>Es6： import&#x2F;export</li>
<li>commonjs：require&#x2F;exports&#x2F;module.export</li>
</ul>
<h4 id="require-和-import-的区别"><a href="#require-和-import-的区别" class="headerlink" title="require 和 import 的区别"></a>require 和 import 的区别</h4><ul>
<li>require 支持<em>动态导入</em>，import 不支持，正在提案(babel 下可支持)</li>
<li>require 是<em>同步导入</em>，import 属于<em>异步导入</em> （require 执行时导入，import 编译时导入）</li>
<li>require 是<em>值拷贝</em>，导出值变化不会影响导入值；import 指向<em>内存地址</em>，导入值会随导出值而变化 （但目前都是值拷贝，babel 最终也会把 import 转换为 require）</li>
</ul>
<h3 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h3><p>防抖和节流是对<em>高频触发操作</em>的优化方式，会极大的提升性能</p>
<ul>
<li>防抖 (debounce): 将多次高频操作优化为只在最后一次调用执行，通常使用的场景是：用户输入，只需在输入完成后做一次输入校验即可。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fun, wait = <span class="number">5000</span>, immediately = <span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer, context, args;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...arumens</span>) &#123;</span><br><span class="line">        context = <span class="variable language_">this</span>;</span><br><span class="line">        args = arumens;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (immediately &amp;&amp; !timer) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line"></span><br><span class="line">        timer = <span class="title function_">setTimerOut</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timer = <span class="literal">null</span>;</span><br><span class="line">            fun.<span class="title function_">apply</span>(context, args);</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>节流 (throttle): 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms 执行一次即可。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">func, wait = <span class="number">5000</span>, immediately = <span class="literal">true</span></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> timer,</span><br><span class="line">        context,</span><br><span class="line">        args,</span><br><span class="line">        first = immediately;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...<span class="variable language_">arguments</span></span>) &#123;</span><br><span class="line">        context = <span class="variable language_">this</span>;</span><br><span class="line">        args = <span class="variable language_">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">            first = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = <span class="title function_">setTimeOut</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                fn.<span class="title function_">apply</span>(context, args);</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h3><p><strong>当 js 操作 dom 时，会引发 js 引擎与渲染引擎的交互，多次的交互极大的损失性能，所以现代框架中虚拟 dom 来模拟，多次的操作合并为一次。当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。</strong></p>
<ul>
<li>重绘(repaint):当元素的样式改变而不影响布局时，浏览器将使用重绘对元素进行更新，只是 UI 变现层的更新，因此<strong>损耗较少</strong></li>
<li>回流(reflow):当元素的尺寸、结构或属性发生改变时，引发浏览器的重新渲染，称之为回流。浏览器需要重新计算，计算后还要重新布局，然后 GPU 绘制页面，因此对性能损耗较大，这也是性能优化重要的一点<ul>
<li>容易引发回流的操作<ul>
<li>页面初次渲染</li>
<li>浏览器窗口大小改变</li>
<li>元素尺寸、位置、内容发生改变</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的 dom 元素</li>
<li>激活 CSS 伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>回流必定触发重绘，而重绘不一定触发回流，查询某些属性或调用某些方法</strong></p>
<ul>
<li>减少回流的 css 实践（优化性能）<ul>
<li>css<ul>
<li>避免使用 display:table 布局</li>
<li>将动画应用到脱离文档流的元素上(如 absolute，fixed)</li>
</ul>
</li>
<li>js<ul>
<li>避免频繁操作样式，将多次汇总为一次</li>
<li>尽量用添加 class 进行修改</li>
<li>减少 dom 操作次数，可使用字符串一次插入进去</li>
<li>多次操作一个元素样式时，先 display：none 再操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="http-https"><a href="#http-https" class="headerlink" title="http&#x2F;https"></a>http&#x2F;https</h3><ul>
<li><p>http 协议:</p>
<ul>
<li>1.0<ul>
<li>无法复用 完成就断开 需要重新连接和 Tcp 三次握手</li>
<li>head of line blocking 阻塞 导致请求之间影响</li>
</ul>
</li>
<li>1.1<ul>
<li>长连接 keep-alive</li>
<li>断点续传</li>
<li>cache 缓存<ul>
<li>cache-control 设置最大缓存时间 优先</li>
<li>expires 过期时间判断</li>
<li>Last-Modified 最后一次修改时间</li>
<li>E-tag 文件唯一标示 优先</li>
</ul>
</li>
</ul>
</li>
<li>2.0<ul>
<li>多路复用</li>
<li>服务端推送(websocket)</li>
</ul>
</li>
</ul>
</li>
<li><p>https 协议:</p>
<ul>
<li>证书(公钥)</li>
<li>ssl 加密</li>
<li>443 端口</li>
</ul>
</li>
<li><p>缓存策略：强缓存和协商缓存 一般对不经常修改资源设置强缓存(图片，字体等) js|html 等设置协商缓存</p>
<ul>
<li>强缓存：浏览器判断缓存是否过期，没过期直接使用强缓存<ul>
<li>cache-control：设置最大缓存过期时间(秒) 优先于 expires</li>
<li>expires：设置到期的时间(服务器时间) <strong>客户端可能和服务器时间不同</strong></li>
</ul>
</li>
<li>协商缓存：当缓存过期时，使用强缓存<ul>
<li>Last-Modified：最后一次修改时间 Last-Modified(response) &amp; If-Modified-Since (request，上一次返回的 Last-Modified)<ul>
<li>如果一致，则直接返回 304 通知浏览器使用缓存</li>
<li>不一致 服务器返回新资源 <strong>同一秒修改和获取文件时，获取不到最新</strong></li>
</ul>
</li>
<li>唯一标识方案：Etag(response 携带) &amp; If-None-Match(request 携带，上一次返回的 Etag): 服务器判断资源是否被修改：<ul>
<li>修改了则返回新的资源</li>
<li>如果相同则返回 304 浏览器使用缓存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>缓存失效：有时候更新了文件，但客户端获取不到最新</p>
<ul>
<li>文件名后缀添加版本号 **.js?version&#x3D;1.00</li>
<li>现代化构建工具打包 hash 值文件名</li>
</ul>
</li>
<li><p>缓存配置</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line"></span><br><span class="line">  # 其它配置</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ($request_uri ~* .*[.](js|css|map|jpg|png|svg|ico)$) &#123;</span><br><span class="line">    #非html缓存<span class="number">1</span>个月</span><br><span class="line">    add_header <span class="title class_">Cache</span>-<span class="title class_">Control</span> <span class="string">&quot;public, max-age=2592000&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ($request_filename ~* ^.*[.](html|htm)$) &#123;</span><br><span class="line">    #html文件使用协商缓存</span><br><span class="line">    add_header <span class="title class_">Cache</span>-<span class="title class_">Control</span> <span class="string">&quot;public, no-cache&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>缓存存储位置</li>
</ul>
<p>在浏览器的 network 中每个加载文件的 size 可以看到 如果是 memory cache、disk cache、Service Worker 则来自于缓存，否则为服务端请求文件<br>缓存查找策略为先内存后硬盘</p>
<ul>
<li>memory cache：内存缓存</li>
<li>disk cache：硬盘缓存</li>
<li>Service Worker：浏览器缓存</li>
</ul>
<h3 id="http-状态码"><a href="#http-状态码" class="headerlink" title="http 状态码"></a>http 状态码</h3><ul>
<li>1**：接受，继续处理</li>
<li>200：成功，并返回数据</li>
<li>201：已创建</li>
<li>202：已接受</li>
<li>203：成功，并返回数据</li>
<li>204：成功，无内容</li>
<li>205：成功，重置内容</li>
<li>206：成功，部分内容</li>
<li>301：重定向</li>
<li>302：临时移动，可使用原 url</li>
<li>304：资源未修改，可使用缓存</li>
<li>305：需要代理访问</li>
<li>400：语法错误</li>
<li>401：需要身份认证</li>
<li>403：拒绝请求</li>
<li>404：资源不存在</li>
<li>500：服务器错误</li>
</ul>
<h3 id="get-post-区别"><a href="#get-post-区别" class="headerlink" title="get&#x2F;post 区别"></a>get&#x2F;post 区别</h3><ul>
<li>get：可以被缓存&#x2F;请求长度受限制(4k)&#x2F;会被历史记录&#x2F;不会修改资源</li>
<li>post：安全&#x2F;数据传输大&#x2F;更多编码类型</li>
</ul>
<h3 id="cookie-和-seesion-和-localstorage-的区别"><a href="#cookie-和-seesion-和-localstorage-的区别" class="headerlink" title="cookie 和 seesion 和 localstorage 的区别"></a>cookie 和 seesion 和 localstorage 的区别</h3><ul>
<li>时效性： cookie 一般有过期时间 localstorage 不清楚永远存在 seesion 窗口打开期间</li>
<li>存储大小：coookie 一般 4K 左右 localstorage session 5M 左右</li>
<li>服务器交互：cookie 会在交互时在请求头携带 其他不会</li>
</ul>
<h3 id="Node-的-EventLoop-的-6-个阶段"><a href="#Node-的-EventLoop-的-6-个阶段" class="headerlink" title="Node 的 EventLoop 的 6 个阶段"></a>Node 的 EventLoop 的 6 个阶段</h3><ul>
<li><p>timer 阶段：执行到期的定时器 setTimeout 和 setInterval 的回掉</p>
</li>
<li><p>I&#x2F;O 阶段：执行上轮循环残留的 callback</p>
</li>
<li></li>
</ul>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><ul>
<li>JSONP：利用 script 标签不受限制的特点，但只支持 get 请求</li>
<li>设置 CORS：Access-Control-Allow-Origin：*</li>
<li>postMessage：window.postMessage</li>
<li>设置 domain：同一主域名下</li>
</ul>
<h3 id="script-的-src-和-img-的-src-跨域的区别"><a href="#script-的-src-和-img-的-src-跨域的区别" class="headerlink" title="script 的 src 和 img 的 src 跨域的区别"></a>script 的 src 和 img 的 src 跨域的区别</h3><p>原理是相同的，都是利用标签的 src 属性可以跨域请求的特点，但是具体的实现不同。<br>使用 img 标签不能访问服务器返回的响应内容，也就是说只能单向的发送 get 请求。<br>而使用 script 标签实现的 jsonp 跨域可以将服务器响应文本以函数参数的形式返回，浏览器解析 js 代码时直接就执行了。</p>
<h3 id="跨域站点请求-cookie-问题"><a href="#跨域站点请求-cookie-问题" class="headerlink" title="跨域站点请求 cookie 问题"></a>跨域站点请求 cookie 问题</h3><p>当发送一个跨域请求时不会主动携带 cookie，请求头需要设置 withCredentials:true，同时服务端设置 Access-Control-Allow-Credentials:true</p>
<p>XMLHttpRequest.withCredentials 属性是一个 Boolean 类型，它指示了是否该使用类似 cookies,authorization headers(头部授权)或者 TLS 客户端证书这一类资格证书来<strong>创建一个跨站点访问控制</strong>（cross-site Access-Control）请求。该请求依然享受同源策略，因此不能被通过 document.cookie 或者从头部相应请求的脚本等访问。在同一个站点下使用 withCredentials 属性是无效的。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul>
<li>XSS 攻击：跨站脚本：利用浏览器的输入输出漏洞进行脚本攻击<ul>
<li>危害<ul>
<li>窃取 cookie 信息</li>
<li>监听用户行为</li>
<li>修改 dom，伪造登录页面</li>
</ul>
</li>
<li>类型<ul>
<li>存储型：黑客输入脚本然后存入该站点数据库，用户访问时请求就包含了恶意脚本，执行就会被窃取用户信息</li>
<li>反射型：该类型不需要存储在数据库，恶意链接会携带 js 脚本，然后在页面中执行，触发恶意操作</li>
<li>基于 DOM：通过手段修改 dom，html 传输中或使用中被劫持，然后修改 dom</li>
</ul>
</li>
<li>防范<ul>
<li>重要数据 httpOnly</li>
<li>对页面上的输入和输出内容进行转义或过滤</li>
<li>利用 CSP（同源策略）：禁止加载或者执行其他域下的脚本</li>
</ul>
</li>
</ul>
</li>
<li>CSRFF：跨站伪装请求：访问第三方站点时，利用用户的登录态调取接口<ul>
<li>危害<ul>
<li>窃取 cookie 信息</li>
<li>伪装请求来让操作用户数据或财产</li>
</ul>
</li>
<li>类型<ul>
<li>伪造 get 请求（img\src 等标签自动发起请求）</li>
<li>伪造 post 请求（表单自动提交）</li>
<li>吸引用户点击第三方站点链接</li>
</ul>
</li>
<li>防范<ul>
<li>get 不修改数据</li>
<li>禁止第三方网站发送 cookie：设置 cookit 的 sameSite（Strict|Lax|None）</li>
<li>CSRF Token：第一次请求下发 CSRF Token、接口请求携带并校验</li>
<li>设置白名单，不被第三方请求</li>
<li>请求来源校验（origin、refer：安全原因有时候没有）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="虚拟-dom-diff-原理和实现"><a href="#虚拟-dom-diff-原理和实现" class="headerlink" title="虚拟 dom diff 原理和实现"></a>虚拟 dom diff 原理和实现</h3><ul>
<li><p>真实 dom 初始化为虚拟 dom 树</p>
</li>
<li><p>树的 diff，深度遍历，添加索引(方便渲染差异)，同层对比 输出（diffList，diffchildren，diffprops）</p>
<ul>
<li>没有新的节点，返回</li>
<li>有新的节点，tagname 和 key 相同，对比属性，遍历子节点<ul>
<li>对比属性(新旧属性列表)<ul>
<li>是否有删除属性</li>
<li>是否属性值修改</li>
<li>是否有新加属性</li>
</ul>
</li>
<li>对比列表(新旧列表)<ul>
<li>是否有删除</li>
<li>是否有新增</li>
<li>是否移动</li>
</ul>
</li>
</ul>
</li>
<li>tagname 和 key 不同，直接替换该节点</li>
</ul>
</li>
<li><p>渲染差异：根据前后虚拟 dom 的差异节点渲染真实 dom</p>
<ul>
<li>遍历 patchs， 把需要更改的节点取出来</li>
<li>局部更新 dom</li>
</ul>
</li>
<li><p>js 模拟 dom 对象的实现</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Elemnet</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">tags,props,children,key</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tags</span> = tags;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span> = props;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(children))&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">children</span> = children</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="title function_">isString</span>(children))&#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">key</span> = children;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">children</span> = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key) <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> root = <span class="variable language_">this</span>.<span class="title function_">_createHtml</span>(</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tags</span>,</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">props</span>,</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">children</span>,</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">key</span></span><br><span class="line">    )</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(root)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">create</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">_createHtml</span>(</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">tags</span>,</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">props</span>,</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">children</span>,</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">key</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">_createHtml</span>(<span class="params">tags,props,children,key</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> el = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(tags);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> props)&#123;</span><br><span class="line">      <span class="keyword">if</span> (props.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = props[key];</span><br><span class="line">        el.<span class="title function_">setAttribute</span>(key,value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key) el.<span class="property">key</span> = key</span><br><span class="line">    <span class="keyword">if</span>(children)&#123;</span><br><span class="line">      children.<span class="title function_">forEach</span>(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> child;</span><br><span class="line">        <span class="keyword">if</span>(e instanceOf <span class="title class_">Element</span>)&#123;</span><br><span class="line">          e = <span class="variable language_">this</span>.<span class="title function_">_createHtml</span>(e)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          child = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        el.<span class="title function_">appendChild</span>(child)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="diff-算法实现"><a href="#diff-算法实现" class="headerlink" title="diff 算法实现"></a>diff 算法实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">diff</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pathchs = &#123;&#125;; <span class="comment">//收集差异</span></span><br><span class="line">        <span class="title function_">difers</span>(newTrees, oldTrees, <span class="number">0</span>, pathchs);</span><br><span class="line">        <span class="keyword">return</span> pathchs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">difers</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="vue3-0-中-proxy-相比于-defineProperty-的优点"><a href="#vue3-0-中-proxy-相比于-defineProperty-的优点" class="headerlink" title="vue3.0 中 proxy 相比于 defineProperty 的优点"></a>vue3.0 中 proxy 相比于 defineProperty 的优点</h3><ul>
<li><p>defineProperty 只能对属性进行劫持，所以需要深度遍历整个对象。proxy 直接对整个对象进行拦截</p>
</li>
<li><p>不能监听到对象新增的属性、数组 push、unshift 方法增加元素的变化 proxy 原生全都支持</p>
</li>
<li><p>proxy 后操作的对象为，Proxy 后的实例对象而不是原始对象，Proxy 后的对象的 this 也指向新的实例代理对象</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">    <span class="title function_">m</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 检查this的指向是不是proxyObkj</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === proxyObj);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> proxyObj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxyObj.<span class="title function_">m</span>(); <span class="comment">//输出:true</span></span><br><span class="line">target.<span class="title function_">m</span>(); <span class="comment">//输出:false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>proxy 缺点：由于 proxy 后的对象 this 指向也发生了改变，所以需要 this 来获取值的对象也不能正确代理，如下：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line"></span><br><span class="line">proxyObj.<span class="title function_">getDate</span>(); <span class="comment">// TypeError: this is not a Date object.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;2015-01-01&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, prop</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prop === <span class="string">&quot;getDate&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 改变this指向</span></span><br><span class="line">            <span class="keyword">return</span> target.<span class="property">getDate</span>.<span class="title function_">bind</span>(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(target, handler);</span><br><span class="line">proxy.<span class="title function_">getDate</span>(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="react-redux-和-mobx-的区别"><a href="#react-redux-和-mobx-的区别" class="headerlink" title="react-redux 和 mobx 的区别"></a>react-redux 和 mobx 的区别</h3><ul>
<li>mobx 入门更简单 redux 相对较难</li>
<li>mobx 异步更加方便 redux 需要中间件来支持</li>
<li>mobx 是对数据的引用 可直接修改数据的状态 redux 是 immutable 的思想 每次返回新的对象 需要数据流的方式去修改状态</li>
<li>正是因为这个 所以 mobx 更适合小项目 没有很多数据的管理 大型项目多人协作开发会容易引发冲突</li>
</ul>
<h3 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for..in 和 for..of 的区别"></a>for..in 和 for..of 的区别</h3><ul>
<li>for..in：会对对象的 key 值进行遍历 如果是数组会遍历下标(多维数组不可遍历)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当给数组添加属性时，也会被遍历</span><br><span class="line"><span class="built_in">let</span> arr = [1,2,3];</span><br><span class="line">arr.name = <span class="string">&#x27;w&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i <span class="keyword">in</span> arr)&#123;</span><br><span class="line">  console.log(i)   //0,1,2,name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>for..of：会对对象的值进行遍历 还可以通过下标拿到子属性的值 只会遍历集合本身元素</li>
</ul>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><ul>
<li>&amp;位与运算</li>
</ul>
<p>1&amp;2 &#x3D;&gt; 0001&amp;0010 &#x3D;&gt; 0<br>15&amp;14 &#x3D;&gt; 1111&amp;1110 &#x3D;&gt; 1110 取都等于 1 的公共位</p>
<ul>
<li>&lt;&lt;位左移运算<br>1&lt;&lt;2 &#x3D;&gt; 0001 左移两位 &#x3D;&gt; 0100 &#x3D;&gt; 4</li>
</ul>
<h3 id="模块化和组件化"><a href="#模块化和组件化" class="headerlink" title="模块化和组件化"></a>模块化和组件化</h3><ul>
<li>模块化：是从逻辑上的划分，考虑代码的组织</li>
<li>组件化：是从 UI 上的划分，考虑代码的复用</li>
</ul>
<h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><p>首先介绍一些用户体验的相关概念：</p>
<ul>
<li>主动交互：需要用户去点击去触发的一些操作产生的交互 比如点击</li>
<li>被动交互：不需要用户去操作 就可以在视觉上与用户产生交互 比如 开屏广告 动画 loading</li>
<li>刷新率：屏幕每秒钟刷新的频率，这是显示设备优劣的参考值之一 值越高屏幕的流畅性越高 用户体验越好</li>
<li>FPS：每秒钟往屏幕上传输的图像数量，玩游戏的朋友都应该知道这个东西，值低于 60 会开始明显感觉到卡顿</li>
</ul>
<p>体验案例:苹果的通用页面 点击会延时进入下一个页面 而不会进去后显示一个 loading 尽管那个 loading 很短 但很影响用户的体验性</p>
<h5 id="如何优化长任务"><a href="#如何优化长任务" class="headerlink" title="如何优化长任务"></a>如何优化长任务</h5><p>因为每一秒需要至少 60 帧的渲染频率，每一帧也就是 16.7ms，所以为了用户体验，我们应避免长任务，尤其是超过运行超过 10ms 的任务，因为在每一帧还需要给浏览器渲染预留时间。</p>
<p>但是如果是超过 10ms 的长任务应该怎么办呢，有两种方案，Web Worker 和 Time Slicing</p>
<ul>
<li>Web Woker：就是重启一个线程来运行长任务，而避免主线程的阻塞，而导致浏览器卡死。但缺点是无法操作 dom</li>
<li>Time Slicing：时间切片的概念，就是把长任务进行切割成多个执行时间很短的段任务，因为每个任务之间需要间隔，所以肯定比长任务时间长，但是基本可以做到用户无感知，例如 react 的 Fiber 调度系统，一个长任务可以被多次中断执行。</li>
</ul>
<h6 id="去渲染数据量超大的一个列表页如何优化"><a href="#去渲染数据量超大的一个列表页如何优化" class="headerlink" title="去渲染数据量超大的一个列表页如何优化"></a>去渲染数据量超大的一个列表页如何优化</h6><ul>
<li>时间切片：把一次渲染 40000 条数据切割成多次去渲染</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;any, any&gt; &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">list</span>: [],</span><br><span class="line">    &#125;;</span><br><span class="line">    handerClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">sliceTime</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">40000</span>).<span class="title function_">fill</span>(<span class="number">0</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    sliceTime = <span class="function">(<span class="params">list, times</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (times === <span class="number">400</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> newList = list.<span class="title function_">slice</span>(</span><br><span class="line">                times * <span class="number">100</span>,</span><br><span class="line">                (times + <span class="number">1</span>) * <span class="number">100</span></span><br><span class="line">            ); <span class="comment">/* 每次截取 100 个 */</span></span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">                <span class="attr">list</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">list</span>.<span class="title function_">concat</span>(newList),</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">sliceTime</span>(list, times + <span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; list &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handerClick&#125;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;list.map((item, index) =&gt; (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">li</span> <span class="attr">className</span>=<span class="string">&quot;list&quot;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        &#123;item + &quot;&quot; + index&#125; Item</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                ))&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>虚拟列表：lib:react-tiny-virtual-list</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只渲染当前视口范围和缓存区内的数据，列表滚动时当前让渲染区域也进行滚动，根据滚动多少计算应该展示的渲染条目</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Index</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span>&lt;any, any&gt; &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">list</span>: <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">9999</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            num++;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="attr">scorllBoxHeight</span>: <span class="number">500</span> <span class="comment">/* 容器高度(初始化高度) */</span>,</span><br><span class="line">        <span class="attr">renderList</span>: [] <span class="comment">/* 渲染列表 */</span>,</span><br><span class="line">        <span class="attr">itemHeight</span>: <span class="number">60</span> <span class="comment">/* 每一个列表高度 */</span>,</span><br><span class="line">        <span class="attr">bufferCount</span>: <span class="number">8</span> <span class="comment">/* 缓冲个数 上下四个 */</span>,</span><br><span class="line">        <span class="attr">renderCount</span>: <span class="number">0</span> <span class="comment">/* 渲染数量 */</span>,</span><br><span class="line">        <span class="attr">start</span>: <span class="number">0</span> <span class="comment">/* 起始索引 */</span>,</span><br><span class="line">        <span class="attr">end</span>: <span class="number">0</span> <span class="comment">/* 终止索引 */</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="attr">listBox</span>: any = <span class="literal">null</span>;</span><br><span class="line">    <span class="attr">scrollBox</span>: any = <span class="literal">null</span>;</span><br><span class="line">    <span class="attr">scrollContent</span>: any = <span class="literal">null</span>;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; itemHeight, bufferCount &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">        <span class="comment">/* 计算容器高度 */</span></span><br><span class="line">        <span class="keyword">const</span> scorllBoxHeight = <span class="variable language_">this</span>.<span class="property">listBox</span>.<span class="property">offsetHeight</span>;</span><br><span class="line">        <span class="keyword">const</span> renderCount =</span><br><span class="line">            <span class="title class_">Math</span>.<span class="title function_">ceil</span>(scorllBoxHeight / itemHeight) + bufferCount;</span><br><span class="line">        <span class="keyword">const</span> end = renderCount + <span class="number">1</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            scorllBoxHeight,</span><br><span class="line">            end,</span><br><span class="line">            renderCount,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理滚动效果 */</span></span><br><span class="line">    handerScroll = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; scrollTop &#125;: any = <span class="variable language_">this</span>.<span class="property">scrollBox</span>;</span><br><span class="line">        <span class="keyword">const</span> &#123; itemHeight, renderCount &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">        <span class="keyword">const</span> currentOffset = scrollTop - (scrollTop % itemHeight);</span><br><span class="line">        <span class="comment">/* translate3d 开启css cpu 加速 */</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">scrollContent</span>.<span class="property">style</span>.<span class="property">transform</span> = <span class="string">`translate3d(0, <span class="subst">$&#123;currentOffset&#125;</span>px, 0)`</span>;</span><br><span class="line">        <span class="keyword">const</span> start = <span class="title class_">Math</span>.<span class="title function_">floor</span>(scrollTop / itemHeight);</span><br><span class="line">        <span class="keyword">const</span> end = <span class="title class_">Math</span>.<span class="title function_">floor</span>(scrollTop / itemHeight + renderCount + <span class="number">1</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            start,</span><br><span class="line">            end,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">/* 性能优化：只有在列表start 和 end 改变的时候在渲染列表 */</span></span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">_nextProps, _nextState</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; start, end &#125; = _nextState;</span><br><span class="line">        <span class="keyword">return</span> start !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">start</span> || end !== <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 处理滚动效果 */</span></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1111</span>);</span><br><span class="line">        <span class="keyword">const</span> &#123; list, scorllBoxHeight, itemHeight, start, end &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">        <span class="keyword">const</span> renderList = list.<span class="title function_">slice</span>(start, end);</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list_box&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> (this.listBox = node)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">height:</span> <span class="attr">scorllBoxHeight</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">overflow:</span> &quot;<span class="attr">scroll</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">position:</span> &quot;<span class="attr">relative</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> (this.scrollBox = node)&#125;</span></span><br><span class="line"><span class="language-xml">                    onScroll=&#123;this.handerScroll&#125;</span></span><br><span class="line"><span class="language-xml">                &gt;</span></span><br><span class="line"><span class="language-xml">                    &#123;/* 占位作用 */&#125;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            <span class="attr">height:</span> `$&#123;<span class="attr">list.length</span> * <span class="attr">itemHeight</span>&#125;<span class="attr">px</span>`,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            <span class="attr">position:</span> &quot;<span class="attr">absolute</span>&quot;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            <span class="attr">left:</span> <span class="attr">0</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            <span class="attr">top:</span> <span class="attr">0</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                            <span class="attr">right:</span> <span class="attr">0</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    /&gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;/* 显然区 */&#125;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                        <span class="attr">ref</span>=<span class="string">&#123;(node)</span> =&gt;</span> (this.scrollContent = node)&#125;</span></span><br><span class="line"><span class="language-xml">                        style=&#123;&#123;</span></span><br><span class="line"><span class="language-xml">                            position: &quot;relative&quot;,</span></span><br><span class="line"><span class="language-xml">                            left: 0,</span></span><br><span class="line"><span class="language-xml">                            top: 0,</span></span><br><span class="line"><span class="language-xml">                            right: 0,</span></span><br><span class="line"><span class="language-xml">                        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">                    &gt;</span></span><br><span class="line"><span class="language-xml">                        &#123;renderList.map((item, index) =&gt; (</span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list&quot;</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                                &#123;item + &quot;&quot;&#125; Item</span></span><br><span class="line"><span class="language-xml">                            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        ))&#125;</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="react17"><a href="#react17" class="headerlink" title="react17"></a>react17</h5><p>重写调度器系统，把同步长任务变成异步短任务，把渲染分布到每一帧的空隙去执行</p>
<h4 id="instandof"><a href="#instandof" class="headerlink" title="instandof"></a>instandof</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instanceNew</span>(<span class="params">obj, constructor</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = obj.<span class="property">__proto__</span>;</span><br><span class="line">    <span class="keyword">while</span> (a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a === constructor.<span class="property"><span class="keyword">prototype</span></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a.<span class="property">__proto__</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="切片上传"><a href="#切片上传" class="headerlink" title="切片上传"></a>切片上传</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">handleChange</span> = (<span class="params">e</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> file = e.<span class="property">target</span>.<span class="property">files</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> start = <span class="number">0</span>,</span><br><span class="line">        end = <span class="number">0</span>,</span><br><span class="line">        chunks = [],</span><br><span class="line">        chunkSize = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">if</span> (file.<span class="property">size</span> &gt; chunkSize) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            end += chunkSize;</span><br><span class="line">            <span class="keyword">var</span> blob = file.<span class="title function_">slice</span>(start, end);</span><br><span class="line">            start += chunkSize;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!blob.<span class="property">size</span>) &#123;</span><br><span class="line">                <span class="comment">//截取的数据为空 则结束</span></span><br><span class="line">                <span class="comment">//拆分结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            chunks.<span class="title function_">push</span>(blob); <span class="comment">//保存分段数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        chunks.<span class="title function_">push</span>(file);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(chunks);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h4><p><strong>当通过 window.open 打开一个窗口时，打开的窗口可以通过 window.opener 拿到父窗口的信息。这种可以用于子窗口在作出一些操作时，对父窗口进行一些回调操作。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///父窗口</span></span><br><span class="line"><span class="variable language_">window</span>[<span class="string">&quot;callback&quot;</span>] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">111</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">open</span>(<span class="string">&quot;子窗口&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">///子窗口</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="variable language_">window</span>.<span class="property">opener</span>[<span class="string">&quot;callback&quot;</span>]; <span class="comment">//拿到父窗口回调方法</span></span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line"><span class="title function_">callback</span>();</span><br></pre></td></tr></table></figure>

<h4 id="Objeck-key-自动排序问题"><a href="#Objeck-key-自动排序问题" class="headerlink" title="Objeck.key() 自动排序问题"></a>Objeck.key() 自动排序问题</h4><p>利用 Object.keys 取得对象所有属性的 key ，然后进行 map 操作是 JavaScript 开发者常用的方法，但是如果后续逻辑依赖于 map 的索引值，那可能会出现问题。举例如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="string">&quot;1a&quot;</span>: <span class="string">&quot;a&quot;</span>, <span class="string">&quot;2b&quot;</span>: <span class="string">&quot;b&quot;</span>, <span class="string">&quot;3c&quot;</span>: <span class="string">&quot;c&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Object</span>.<span class="title function_">keys</span>(a); <span class="comment">// [&#x27;1a&#x27;,&#x27;2b&#x27;,&#x27;3c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = &#123; ...a, <span class="number">11</span>: <span class="string">&quot;d&quot;</span> &#125;; <span class="comment">// &#123; &#x27;11&#x27;: &#x27;d&#x27;, &#x27;1a&#x27;: &#x27;a&#x27;, &#x27;2b&#x27;: &#x27;b&#x27;, &#x27;3c&#x27;: &#x27;c&#x27; &#125; 自动被排序</span></span><br><span class="line"><span class="keyword">const</span> newArr = <span class="title class_">Object</span>.<span class="title function_">keys</span>(newObj); <span class="comment">// [&#x27;11&#x27;, &#x27;1a&#x27;,&#x27;2b&#x27;,&#x27;3c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>因此当对象中出纯数字或者以数字开头时，使用时可能会被排序，自动排到最前面，可能导致后续 Object.keys()操作出现问题。因为不同的引擎的处理不同，所以这个问题有可能会出现。</p>
<h5 id="文档描述"><a href="#文档描述" class="headerlink" title="文档描述"></a>文档描述</h5><p>Object.keys() 在执行过程中，若发现 key 是整数类型索引，那它首先按照从小到大排序加入；然后再按照先来先到的创建顺序加入其他元素，最后加入 Symbol 类型的 key。</p>
<h6 id="key-何时会被识别为“整数”？"><a href="#key-何时会被识别为“整数”？" class="headerlink" title="key 何时会被识别为“整数”？"></a>key 何时会被识别为“整数”？</h6><ul>
<li>当 key 为数字开头时，也会被识别为整数，按照规则排序。</li>
<li>当纯数字&lt;4294967295,会被识别，否则失效，按照先来先到的顺序排序</li>
</ul>
<h5 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h5><p>Object.keys() 的返回并不总能保持先来后到的顺序。从解决业务需要的角度，我们可以通过维护一个单独的 tag 数组来回避这个问题。</p>
<h5 id="暗黑模式"><a href="#暗黑模式" class="headerlink" title="暗黑模式"></a>暗黑模式</h5><p>@media (prefers-color-scheme: dark) {<br>html {<br>filter: invert(100%) hue-rotate(180deg);<br>}<br>}</p>
<h4 id="文件上传的几种方式"><a href="#文件上传的几种方式" class="headerlink" title="文件上传的几种方式"></a>文件上传的几种方式</h4><ul>
<li>action-form： form 表单的方式</li>
<li>formData：创建 formData， 然后 append 上传的 file</li>
<li>base64：文件转换成 base64 然后接口上传</li>
</ul>
<h4 id="ios-上切屏或息屏倒计时停止问题"><a href="#ios-上切屏或息屏倒计时停止问题" class="headerlink" title="ios 上切屏或息屏倒计时停止问题"></a>ios 上切屏或息屏倒计时停止问题</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时器</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">handleTimer</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">        <span class="keyword">const</span> remainSec = (info.<span class="property">answerDuration</span> * <span class="number">60</span> - info.<span class="property">useTime</span> + <span class="number">1</span>) * <span class="number">1000</span>;</span><br><span class="line">        timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">//第二种方案 进入页面是记录时间戳 -&gt; 定时器每次计算当前所用时间 -&gt; 计算出剩余时间显示出来</span></span><br><span class="line">            <span class="keyword">let</span> diff = <span class="title function_">moment</span>(<span class="title function_">moment</span>()).<span class="title function_">diff</span>(timestamp);</span><br><span class="line">            <span class="keyword">const</span> sec = <span class="title class_">Math</span>.<span class="title function_">ceil</span>((remainSec - diff) / <span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (sec == <span class="number">600</span>) <span class="title class_">Toast</span>.<span class="title function_">info</span>(<span class="string">&quot;考试时间还剩10分钟&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (sec &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">                <span class="title function_">setVisible</span>(<span class="literal">true</span>);</span><br><span class="line">                str = <span class="title function_">zerofill</span>(<span class="number">0</span>) + <span class="string">&quot;:&quot;</span> + <span class="title function_">zerofill</span>(<span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> min = <span class="title class_">Math</span>.<span class="title function_">floor</span>(sec / <span class="number">60</span>);</span><br><span class="line">                <span class="keyword">const</span> second = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(sec % <span class="number">60</span>);</span><br><span class="line">                str = <span class="title function_">zerofill</span>(min) + <span class="string">&quot;:&quot;</span> + <span class="title function_">zerofill</span>(second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_">setTimeText</span>(str);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closeTime) &#123;</span><br><span class="line">        <span class="comment">// 页面显示后 计算息屏时间  剩余倒计时 = 息屏前倒计时时间 - 息屏时间</span></span><br><span class="line">        diff = diff2 - ((<span class="title class_">Date</span>.<span class="title function_">now</span>() - closeTime) / <span class="number">1000</span>).<span class="title function_">toFixed</span>(<span class="number">0</span>); <span class="comment">// 重置倒计时时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方案 计算息屏时间 重置倒计时时间</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;visibilitychange&quot;</span>, resetTime); <span class="comment">// 监听页面显示状态</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;visibilitychange&quot;</span>, resetTime);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">resetTime</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">document</span>.<span class="property">hidden</span>) &#123;</span><br><span class="line">        <span class="comment">//页面隐藏 记录当前时间戳和剩余倒计时时间</span></span><br><span class="line">        diff2 = diff;</span><br><span class="line">        closeTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">handleTimer</span>(); <span class="comment">//页面显示 重新倒计时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进入时开始倒计时  页面摧毁后清楚定时器</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (info.<span class="property">answerStatus</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="title function_">handleTimer</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4444</span>);</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;, [info]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种方案</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Countdown</span>, &#123; zeroPad &#125; <span class="keyword">from</span> <span class="string">&quot;react-countdown&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">renderer</span> = (<span class="params">&#123; hours, minutes, seconds, completed &#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (completed) &#123;</span><br><span class="line">        <span class="comment">//倒计时完成</span></span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (minutes == <span class="number">10</span> &amp;&amp; seconds == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;zeroPad(hours)&#125;:&#123;zeroPad(minutes)&#125;:&#123;zeroPad(seconds)&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">react-countdown</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">date</span>=<span class="string">&#123;Date.now()</span> + <span class="attr">diff</span>&#125; //<span class="attr">截止时间</span> <span class="attr">未来的某个时间</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">renderer</span>=<span class="string">&#123;renderer&#125;</span> // <span class="attr">自定义渲染展示的内容</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="Generator-模拟-async-await"><a href="#Generator-模拟-async-await" class="headerlink" title="Generator 模拟 async await"></a>Generator 模拟 async await</h4><p>都说 async await 是 generator 的语法糖实现，那到底是怎么实现的呢，我们使用 generator 模拟实现一个 async await 就知道了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getData</span> = (<span class="params"></span>) =&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&quot;data&quot;</span>), <span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">getData</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data: &quot;</span>, data);</span><br><span class="line">    <span class="keyword">const</span> data2 = <span class="keyword">await</span> <span class="title function_">getData</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data2: &quot;</span>, data2);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用generator表示</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">testG</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">yield</span> <span class="title function_">getData</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data: &quot;</span>, data);</span><br><span class="line">    <span class="keyword">const</span> data2 = <span class="keyword">yield</span> <span class="title function_">getData</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;data2: &quot;</span>, data2);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//async执行后自动从上到下执行 而generator需要每次手动调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行原理</span></span><br><span class="line"><span class="keyword">const</span> gen = <span class="title function_">testG</span>(); <span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">const</span> &#123; dataPromise, isDone &#125; = gen.<span class="title function_">next</span>(); <span class="comment">//执行yield getData() 返回一个promise和迭代器的结果 但并不会把值赋给data 因为现在值还是promise</span></span><br><span class="line"></span><br><span class="line">dataPromise.<span class="title function_">then</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dataPromise2, isDone &#125; = gen.<span class="title function_">next</span>(val); <span class="comment">//把值赋给data  执行下一个yield getData()</span></span><br><span class="line">    dataPromise2.<span class="title function_">then</span>(<span class="function">(<span class="params">val2</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; dataPromise3, isDone &#125; = gen.<span class="title function_">next</span>(val2); <span class="comment">// 同理把值赋给data2  isDone = true 迭代器执行结束</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//知道了执行原理 我们通过函数自动化的执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">asyncToGenerator</span>(<span class="params">generatorFn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> gen = generatorFn.<span class="title function_">app</span>(<span class="variable language_">this</span>); <span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">step</span>(<span class="params">key, arg</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> result;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = step[key](arg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">                <span class="title function_">reject</span>(error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">const</span> &#123; value, isDone &#125; = result;</span><br><span class="line">            <span class="keyword">if</span> (isDone) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_">resolve</span>(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(value).<span class="title function_">then</span>(</span><br><span class="line">                    <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="title function_">step</span>(<span class="string">&quot;next&quot;</span>, val),</span><br><span class="line">                    <span class="function">(<span class="params">error</span>) =&gt;</span> <span class="title function_">reject</span>(error)</span><br><span class="line">                ); <span class="comment">// 迭代器未结束 继续执行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">step</span>(<span class="string">&quot;next&quot;</span>); <span class="comment">//第一次执行yield</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="B-站弹幕如何不遮挡人物"><a href="#B-站弹幕如何不遮挡人物" class="headerlink" title="B 站弹幕如何不遮挡人物"></a>B 站弹幕如何不遮挡人物</h4><p>1.对视频进行 AI 图像识别生成图片层 有人物地方为黑色 其他为透明<br>2.css mask-image 属性对图层黑色的地方进行遮罩 做到不显示弹幕</p>
<h4 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h4><ul>
<li>painter JSON 配置生成海报</li>
</ul>
<h4 id="babel-config-js-和-babelrc-文件区别"><a href="#babel-config-js-和-babelrc-文件区别" class="headerlink" title="babel.config.js 和 .babelrc 文件区别"></a>babel.config.js 和 .babelrc 文件区别</h4><p>babel.config.js 会编译所有文件 包括 node_modules<br>.babelrc 只会编辑当前项目文件</p>
<h4 id="position-sticky-生成条件"><a href="#position-sticky-生成条件" class="headerlink" title="position:sticky 生成条件"></a>position:sticky 生成条件</h4><p>粘性定位，该定位基于用户的滚动位置来定位。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p>
<p>基于的父级元素中不能为 overflow：hidden</p>
<h4 id="babel-源码操作-https-babeljs-io-docs-babel-traverse"><a href="#babel-源码操作-https-babeljs-io-docs-babel-traverse" class="headerlink" title="babel 源码操作 https://babeljs.io/docs/babel-traverse"></a>babel 源码操作 <a href="https://babeljs.io/docs/babel-traverse">https://babeljs.io/docs/babel-traverse</a></h4><ul>
<li>@babel&#x2F;parser 将源码解析成 AST</li>
<li>@babel&#x2F;traverse 遍历 AST，对 AST 节点进行操作（增删改查修改属性等）</li>
<li>@babel&#x2F;types 生成 AST 节点</li>
<li>@babel&#x2F;generator 将 AST 转换为代码</li>
</ul>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><ul>
<li>宏任务：setTimeout、setInterval、setImmediate、I&#x2F;O、UI 交互事件</li>
<li>微任务：Promise.then catch finally、process.nextTick、MutationObserver</li>
<li>事件循环：先执行宏任务，再执行微任务，再执行下一个宏任务，再执行微任务，如此往复</li>
</ul>
<h4 id="前端路由"><a href="#前端路由" class="headerlink" title="前端路由"></a>前端路由</h4><ul>
<li>hash 模式：通过监听 hashchange 事件，获取新的 hash 值，根据 hash 值渲染对应的页面</li>
<li>history 模式：通过监听 popstate 事件，获取新的 state，根据 state 渲染对应的页面</li>
</ul>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><ul>
<li>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件</li>
<li>优点：减少内存消耗，动态绑定事件</li>
</ul>
<h4 id="事件冒泡和捕获"><a href="#事件冒泡和捕获" class="headerlink" title="事件冒泡和捕获"></a>事件冒泡和捕获</h4><ul>
<li>事件冒泡：从下到上触发事件</li>
<li>事件捕获：从上到下触发事件</li>
</ul>
<h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><ul>
<li>事件捕获阶段</li>
<li>目标阶段</li>
<li>事件冒泡阶段</li>
</ul>
<h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><ul>
<li>事件代理就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件</li>
</ul>
<h3 id="参数为数组进行-url-传递，如下传递时获取时的值为数组"><a href="#参数为数组进行-url-传递，如下传递时获取时的值为数组" class="headerlink" title="参数为数组进行 url 传递，如下传递时获取时的值为数组"></a>参数为数组进行 url 传递，如下传递时获取时的值为数组</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url:</span><br><span class="line">http://127.0.0.1:8091/scanner/fishing-system/fishing/task-manage?array=1&amp;array=2&amp;array=3</span><br><span class="line">const arr = this.$route.query.array console.log(arr); // [1,2,3]</span><br></pre></td></tr></table></figure>

<h3 id="打开控制台开启-debugger-模式，阻止用户调试代码"><a href="#打开控制台开启-debugger-模式，阻止用户调试代码" class="headerlink" title="打开控制台开启 debugger 模式，阻止用户调试代码"></a>打开控制台开启 debugger 模式，阻止用户调试代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>.<span class="title function_">indexOf</span>(<span class="string">&quot;#debug&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        (<span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title class_">Function</span>(<span class="string">&#x27;Function(arguments[0]+&quot;&#x27;</span> + a + <span class="string">&#x27;&quot;)()&#x27;</span>);</span><br><span class="line">            &#125;)(a);</span><br><span class="line">        &#125;)(<span class="string">&quot;bugger&quot;</span>)(<span class="string">&quot;de&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>

    
    <hr class="fhr" />
    <div id="vcomments"></div>
    
</div>

    <div class="footer" id="footer">
    <p>Copyright © 2020 <a class="flink" href="https://hexo.io">Hexo</a>-<a class="flink" href="https://github.com/sanjinhub/hexo-theme-geek">Geek</a>.
        <label class="el-switch el-switch-green el-switch-sm" style="vertical-align: sub;">
            <input type="checkbox" name="switch" id="update_style">
            <span class="el-switch-style"></span>
        </label>
<!--         <script type="text/javascript">
        var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
        document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
        </script> -->
    </p>
</div>
<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="4QJZu2oB7BcbrCJACqhWnmt2-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="QAjplUsOViSYZJg9F7UAozl8">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
    color: #698fca;
}

.v .vlist .vcard .vhead .vsys {
    color: #3a3e4a;
}

.v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
}

.v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
}

.v a {
    color: #8696b1;
}

.v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
}
</style>
</body>

</html>