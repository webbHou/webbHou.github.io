<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大圣博客</title>
  
  <subtitle>&lt;img src=&quot;/logo.png&quot; style=&quot;width:50px;height:60px;&quot;&gt;</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://webbHou.github.io/"/>
  <updated>2021-07-14T02:55:01.053Z</updated>
  <id>http://webbHou.github.io/</id>
  
  <author>
    <name>webbHou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端微服务的现在及未来的一些思考</title>
    <link href="http://webbHou.github.io/2021/07/14/%E5%89%8D%E7%AB%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%8E%B0%E5%9C%A8%E5%8F%8A%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://webbHou.github.io/2021/07/14/前端微服务的现在及未来的一些思考/</id>
    <published>2021-07-14T02:46:47.000Z</published>
    <updated>2021-07-14T02:55:01.053Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="前端开发" scheme="http://webbHou.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="微服务" scheme="http://webbHou.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>前端常见异常性能监控的几种方式</title>
    <link href="http://webbHou.github.io/2020/12/14/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://webbHou.github.io/2020/12/14/前端常见异常性能监控的几种方式/</id>
    <published>2020-12-14T06:29:22.000Z</published>
    <updated>2021-07-14T02:31:28.468Z</updated>
    
    <content type="html"><![CDATA[<h4 id="常见的几种监控类型"><a href="#常见的几种监控类型" class="headerlink" title="常见的几种监控类型"></a>常见的几种监控类型</h4><ul><li>用户行为监控</li><li>网站异常监控</li><li>网站性能监控</li></ul><h5 id="用户行为监控"><a href="#用户行为监控" class="headerlink" title="用户行为监控"></a>用户行为监控</h5><p>一般大型的网站为了对产品的体验进行更好的优化和改进，所以会采用监控的方式更细致的对用户行为和习惯进行分析，来收集用户习惯和喜好，进行算法的分析，达到个性化的推送和精准的广告投放。常见方式为前端埋点(打点)上报用户行为。</p><h5 id="网站异常监控"><a href="#网站异常监控" class="headerlink" title="网站异常监控"></a>网站异常监控</h5><p>一般的网站在进行上线前会在不同的环境进行多轮的测试，已保证在大部分情况下该网站运行良好、功能可用。但网络环境错综复杂，测试环境不可能百分百的模拟到，所以我们需要进行对网站的运行异常进行监控，及时的发现问题和解决用户使用的体验。</p><h5 id="网站性能监控"><a href="#网站性能监控" class="headerlink" title="网站性能监控"></a>网站性能监控</h5><p>在互联网刚刚出现的时代，开发人员们只需要保证功能可用即可，但是随着互联网高速的发展，从桌面时代到移动时代，从2g到5g，人们的娱乐的方式在大大的改变，也不会再满足于当初的一张图片加载几十秒、网站打开一直等待的速度。所以我们需要改变，需要对网站进行优化，提升用户体验，否则只能被用户所淘汰。所以就需要对网站的打开时间，响应时间等性能相关进行监控，来分析进行如何更好的优化和改进。</p><h4 id="网站异常监控-1"><a href="#网站异常监控-1" class="headerlink" title="网站异常监控"></a>网站异常监控</h4><p>一个监控系统通常分为四个部分：日志采集、日志存储、统计和分析、报告和警告</p><p>日志采集：一般在本地先做一定的处理，然后上报<br>日志存储：BE收到前端数据后进行处理后进行存储<br>统计和分析：分为机器自动分析和人工分析。机器分析就是根据预设的条件和算法，对日志进行分析和筛选，触发对应的报警。人工就是根据可视化的数据面板，查看日志数据，根据信息，发现异常问题根源。<br>报告和警告：分为告警和预警。告警按照一定的级别自动报警，通过设定的渠道，按照一定的触发规则进行。预警则在异常发生前，提前预判，给出警告。</p><ul><li><p>网站异常的几种类型</p><ul><li>出错：页面展现与预期不符的</li><li>呆滞：操作无响应的现象，局部功能不可用</li><li>损坏：界面出现无法实现操作目的的现象</li><li>假死：界面出现卡顿，无法对任何功能进行使用的现象</li><li>崩溃：应用出现经常性自动退出或无法操作的现象</li></ul></li><li><p>网站异常的原因</p><ul><li>逻辑错误：逻辑判断、js对象操作、事件绑定顺序、调用栈顺序错误</li><li>数据类型错误：错误读取property、使用不存在的方法、函数未传参</li><li>语法出错</li><li>网络错误、服务器500前端未做错误处理</li><li>系统错误：浏览器不兼容、内存不够</li></ul></li><li><p>异常日志采集</p><p>1.采集内容：4W原则：WHO did WHAT and get WHICH exception in WHICH environment?</p><ul><li>用户信息</li><li>行为信息</li><li>异常信息</li><li>环境信息</li></ul><p>2.采集方式</p><ul><li><p>全局捕获：</p><ul><li>全局监听：window.addEventListener(‘error’) / window.addEventListener(“unhandledrejection”) / document.addEventListener(‘click’) 全局错误上报</li><li>框架级别：全局interceptor进行拦截上报</li><li>全局封装：调用时自动捕获异常</li><li>重写错误监听方法：对onerror重写，使用方法不变也可以捕获，更易使用    js运行错误时触发上报</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.onerror = <span class="keyword">function</span>(message, <span class="built_in">source</span>, lineno, colno, error) &#123; ... &#125;</span><br><span class="line">函数参数：</span><br><span class="line">- message：错误信息（字符串）。可用于HTML onerror=<span class="string">""</span>处理程序中的event。</span><br><span class="line">- <span class="built_in">source</span>：发生错误的脚本URL（字符串）</span><br><span class="line">- lineno：发生错误的行号（数字）打包压缩后的代码根据sourceMap获取</span><br><span class="line">- colno：发生错误的列号（数字）</span><br><span class="line">- error：Error对象</span><br><span class="line">若该函数返回<span class="literal">true</span>，则阻止执行默认事件处理函数，如异常信息不会在console中打印。没有返回值或者返回值为<span class="literal">false</span>的时候，异常信息会在console中打印</span><br></pre></td></tr></table></figure></li></ul></li><li><p>单点捕获：全局捕获的补充，在业务中对单个代码块进行包裹，或者在逻辑中进行打点，实现有针对性的捕获。</p><ul><li>try-catch</li><li>公共的异常收集方法，异常时调用</li><li>高阶函数：对原函数进行包裹，返回结果相同，只是在异常时会捕获异常。</li></ul></li><li><p>异常录制<br>往往有时候有异常信息我们也不足以发现错误的本质，所以我们希望对异常现场进行还原。通过录制，从时间和空间来记录异常发生前到发生的整个过程，方便我们更好的找到问题的根源。就是通过技术手段，对用户行为进行记录，先存储在用户本地进行分析过滤，一段时间内将用户产生的event和action进行上报。当异常发生后，我们从数据库拿到数据，进行行为的模拟，还原异常情景。</p></li><li><p>日志存储：</p><ul><li>前端：由于用户操作频繁，我们不可能实时上报，那无异于自己在对日志服务器做DDos攻击，所以我们需要首先在前端进行一个数据的持久化的存储。然后在前端进行日志整理，根据异常级别进行索引分类，然后决定是否要批量上报还是一次全部上报。</li><li>服务端：一般会通过单独的日志服务器对上报的日志进行接收，然后还需要对日志的安全性、合法性、有效性进行筛选，防止被攻击。再经过处理后进行服务器存储。</li></ul></li><li><p>统计和分析：<br>根据日志的信息，从用户、行为、异常、环境的各个纬度进行分析，进行异常级别的标注。然后进行可视化的展示，方便管理员和开发者及时可是发现问题。</p></li><li><p>报告和警告<br>根据自定义的触发条件，判断是否需要进行告警处理。推送告警信息到微信、邮箱、短信等各种方式。更加高级的是可以生成报表、产生bug工单，极大的提升了错误的处理效率并记录问题。</p></li><li><p>修复异常</p><ul><li>sourceMap方式发现问题的源码位置，防止源码外漏，可以把souceMap文件发布在内网 使用nginx进行控制</li><li>智能修复：严格的数据模型，当数据返回时，进行模型校验</li><li>预警信息：根据异常的规律，当下次该类型异常发生前进行预警，及时修复</li></ul></li><li><p>异常测试：在测试阶段就进行异常操作进行测试，发现异常类型并统计，在实际用户发生时进行预警。</p></li></ul><h5 id="网站性能监控-1"><a href="#网站性能监控-1" class="headerlink" title="网站性能监控"></a>网站性能监控</h5><ul><li>运行时性能：文件级、模块级、函数级、算法级</li><li>网络请求速率</li><li>系统性能</li></ul><h5 id="API-Monitor"><a href="#API-Monitor" class="headerlink" title="API Monitor"></a>API Monitor</h5><ul><li>稳定性监控</li><li>数据格式和类型</li><li>报错监控</li><li>数据准确性监控</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;常见的几种监控类型&quot;&gt;&lt;a href=&quot;#常见的几种监控类型&quot; class=&quot;headerlink&quot; title=&quot;常见的几种监控类型&quot;&gt;&lt;/a&gt;常见的几种监控类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;用户行为监控&lt;/li&gt;
&lt;li&gt;网站异常监控&lt;/li&gt;
&lt;li&gt;网站性能
      
    
    </summary>
    
      <category term="js常见问题" scheme="http://webbHou.github.io/categories/js%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>微前端的应用和实践</title>
    <link href="http://webbHou.github.io/2020/12/10/%E5%BE%AE%E5%89%8D%E7%AB%AF%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E5%AE%9E%E8%B7%B5/"/>
    <id>http://webbHou.github.io/2020/12/10/微前端的应用和实践/</id>
    <published>2020-12-10T06:34:58.000Z</published>
    <updated>2021-05-21T09:04:55.439Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是微前端"><a href="#什么是微前端" class="headerlink" title="什么是微前端"></a>什么是微前端</h4><p>微前端是多个技术团队通过独立部署单独应用来共同构建应用的一种技术手段。</p><h5 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h5><ul><li>无关技术栈：每一块功能可以使用不同的技术栈去开发、不再对团队的技术栈进行限制和要求</li><li>独立开发、独立部署：每一块功能可以去独立的开发和部署。不需要相互耦合和依赖、可以做到渐进式开发和增量更新</li><li>独立运行时：各个应用间状态隔离不会共享，通信需要主应用进行调度和分配。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是微前端&quot;&gt;&lt;a href=&quot;#什么是微前端&quot; class=&quot;headerlink&quot; title=&quot;什么是微前端&quot;&gt;&lt;/a&gt;什么是微前端&lt;/h4&gt;&lt;p&gt;微前端是多个技术团队通过独立部署单独应用来共同构建应用的一种技术手段。&lt;/p&gt;
&lt;h5 id=&quot;核心特性&quot;&gt;
      
    
    </summary>
    
      <category term="js常见问题" scheme="http://webbHou.github.io/categories/js%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
      <category term="微前端" scheme="http://webbHou.github.io/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Proxy的神奇之处</title>
    <link href="http://webbHou.github.io/2020/12/05/Proxy%E7%9A%84%E7%A5%9E%E5%A5%87%E4%B9%8B%E5%A4%84/"/>
    <id>http://webbHou.github.io/2020/12/05/Proxy的神奇之处/</id>
    <published>2020-12-05T06:15:11.000Z</published>
    <updated>2021-05-21T09:04:55.432Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Proxy"><a href="#什么是Proxy" class="headerlink" title="什么是Proxy"></a>什么是Proxy</h4><p><strong>Proxy对象可以让你为另一个对象创建一个代理，它可以拦截和重新定义该对象的基本操作。</strong></p><h4 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h4><p>一个Proxy的创建有两个参数。</p><ul><li>target：你要创建代理的对象</li><li>handler：定义要被拦截的操作</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;</span><br><span class="line">  name: <span class="string">'webb'</span>,</span><br><span class="line">  age: <span class="number">23</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>: function(target,prop) &#123; <span class="comment">//拦截get操作</span></span><br><span class="line">    <span class="keyword">if</span>(prop === <span class="string">'name'</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> target[<span class="string">'age'</span>]</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> target[<span class="string">'name'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler);</span><br><span class="line"></span><br><span class="line">a.name <span class="comment">//23</span></span><br><span class="line">a.age <span class="comment">//webb</span></span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">更多支持的自定义handler</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是Proxy&quot;&gt;&lt;a href=&quot;#什么是Proxy&quot; class=&quot;headerlink&quot; title=&quot;什么是Proxy&quot;&gt;&lt;/a&gt;什么是Proxy&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Proxy对象可以让你为另一个对象创建一个代理，它可以拦截和重新定义该对象的
      
    
    </summary>
    
      <category term="js" scheme="http://webbHou.github.io/categories/js/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
      <category term="proxy" scheme="http://webbHou.github.io/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>Docker容器入门和实践</title>
    <link href="http://webbHou.github.io/2020/11/25/Docker%E5%85%A5%E9%97%A8%E5%92%8C%E5%AE%9E%E8%B7%B5/"/>
    <id>http://webbHou.github.io/2020/11/25/Docker入门和实践/</id>
    <published>2020-11-25T07:20:05.000Z</published>
    <updated>2021-07-14T02:06:29.217Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要使用docker"><a href="#为什么要使用docker" class="headerlink" title="为什么要使用docker"></a>为什么要使用docker</h4><p>在软件开发中，我们每一个软件应用都需要它自身的运行环境，所以往往我们在本机跑的应用并不代表在别的机器可以跑起来，在本地部署的环境在其他还得重新部署一遍，有时候粗心大意还会缺失，浪费时间精力。所以技术人想为什么我们不把所有这个应用相关的打包到一起，安装的时候把原始环境复制一份到当前机器。</p><p>1.虚拟机vm：就是一种自带环境的解决方案，可以在一个操作系统中再运行一个操作系统。跟你的真实系统基本一样。对于底层来说，虚拟机就是一个文件，不需要了就可以删掉，毫无影响。所以用来还原应用的运行环境特别方便。</p><p>缺点：</p><ul><li>启动慢：因为跟操作系统一样  需要时间启动</li><li>占用内存多：需要自己占用一部分内存(即使可能用不到)，不能共享</li><li>冗余步骤多：因为是操作系统级别的，一些系统的操作不能跳过，比如用户登录</li></ul><p>2.linux容器：进程级的应用，对进程进行隔离，把本地资源做一个映射到该容器去使用，所以本地资源都是虚拟的，从而实现跟本地的隔离。</p><p>优点：</p><ul><li>启动快：进程级别，相当于启动一个进程</li><li>资源占用小：只占用自己用到的部分 不同容器间还可以共享</li><li>体积小：只包含自己用到的组件和依赖</li></ul><h4 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h4><p>linux容器的一种，对linux容器做了一次封装，提供简单易用的容器使用接口。Docker把应用程序相关的都打包到一起，每次运行都会生成一个新的虚拟容器，程序就可以在这个虚拟容器里运行，而不需要担心环境问题。</p><p>用途：</p><ul><li>一次性的安装环境：服务端应用部署、第三方测试、搭建构建环境</li><li>组建微服务架构：比如后端的高并发，可以在多台服务器进行部署进行负载均衡，大量的docker容器可以使用K8s进行管理</li><li>云服务：因为方便管理，启动又快，非常适合扩容和缩容</li></ul><h5 id="image"><a href="#image" class="headerlink" title="image"></a>image</h5><p>Docker把应用程序相关的都打包到一起的文件就叫做image(镜像)，image就相当于模板，通过image才可以生成容器实例，同一个image可以生成多个运行容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取远程仓库镜像到本地 仓库名/image名称</span></span><br><span class="line">$ docker image pull library/hello-world</span><br></pre></td></tr></table></figure><h5 id="container"><a href="#container" class="headerlink" title="container"></a>container</h5><p>运行image生成的容器实例，容器关闭或停止运行并不会删除容器 依旧占用内存</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据hello-world镜像生成并启动一个docker容器 每次都会重新生成</span></span><br><span class="line">docker container run hello-world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死一个容器进程</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止一个容器进程 相对于kill更柔和 不会立马停止</span></span><br><span class="line">$ bash container stop [containerID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动一个已有的容器  </span></span><br><span class="line">$ docker container start [containerID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个容器</span></span><br><span class="line">$ docker container rm [containerID]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">$ docker container ls --all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个容器映射端口并重命名</span></span><br><span class="line">$ docker run -d -p 80:80 --name 容器名  镜像名</span><br></pre></td></tr></table></figure><h4 id="制作docker镜像"><a href="#制作docker镜像" class="headerlink" title="制作docker镜像"></a>制作docker镜像</h4><p>我们可以把自己本地的应用打包成docker容器并发布到远程仓库，就可以在其他机器进行实例化容器</p><ul><li>.dockerignore image打包时忽略文件夹</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><ul><li>Dockerfile：打包image配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4：该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。</span><br><span class="line">COPY . /app：将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。</span><br><span class="line">WORKDIR /app：指定接下来的工作路径为/app。</span><br><span class="line">RUN npm install：在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。RUN命令都在打包完成前执行</span><br><span class="line">EXPOSE 3000：将容器 3000 端口暴露出来， 允许外部连接这个端口。</span><br><span class="line">CMD node demos/01.js 容器启动后自执行命令</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成koa-demo 镜像 -t指定image名称 :指定tag标签 可以做版本管理 .表示Dockerfile配置文件的路径</span></span><br><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure><ul><li>发布image</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成自己仓库名的image</span></span><br><span class="line">$ docker image build -t [username]/[repository]:[tag] .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布</span></span><br><span class="line">$ docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure><h4 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器运行结束后删除</span></span><br><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure><ul><li>-p参数：容器的 3000 端口映射到本机的 8000 端口。</li><li>-it参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li>koa-demo:0.0.1：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li>/bin/bash：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul><h4 id="其他docker命令"><a href="#其他docker命令" class="headerlink" title="其他docker命令"></a>其他docker命令</h4><p>docker login</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要使用docker&quot;&gt;&lt;a href=&quot;#为什么要使用docker&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用docker&quot;&gt;&lt;/a&gt;为什么要使用docker&lt;/h4&gt;&lt;p&gt;在软件开发中，我们每一个软件应用都需要它自身的运行环境，所以
      
    
    </summary>
    
      <category term="计算机知识" scheme="http://webbHou.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
      <category term="docker" scheme="http://webbHou.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式的学习和实践</title>
    <link href="http://webbHou.github.io/2020/11/24/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%AE%9E%E8%B7%B5/"/>
    <id>http://webbHou.github.io/2020/11/24/正则表达式的学习和实践/</id>
    <published>2020-11-24T03:15:12.000Z</published>
    <updated>2021-06-03T06:18:16.982Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h4><table><thead><tr><th>single char(单字符)</th><th>quantifiers(数量)</th><th>position(位置)</th><th>flag</th></tr></thead><tbody><tr><td>\d 匹配数字</td><td>* 0个或多个</td><td>^匹配一行的开头</td><td>g全局匹配</td></tr><tr><td>\w 匹配字母数字</td><td>+ 1个或多个 至少一个</td><td>$匹配一行的结尾</td><td>i忽略大小写</td></tr><tr><td>\W 匹配非数字字母</td><td>? 匹配0个或1个</td><td>\b单词结界</td><td>m多行匹配</td></tr><tr><td>\s 匹配空格</td><td>{min,max} 出现次数在范围内的</td><td>-</td><td>-</td></tr><tr><td>\S 匹配非空格</td><td>{n} 出现n次的</td><td>-</td><td>-</td></tr><tr><td>. 匹配任意字符</td><td>-</td><td>-</td><td>-</td></tr></tbody></table><h5 id="字符分类"><a href="#字符分类" class="headerlink" title="字符分类[]"></a>字符分类[]</h5><ul><li>用来表示逻辑关系或，[abc]表示匹配a或b或c</li><li>字符分类里边的特殊字符不需要转义 [.()]</li><li>当连字符不是第一个字符时 [a-z] 表示匹配从a到z的任意字符</li><li>^在字符分类里表示取反 [^ab] 表示匹配非a非b的任意字符</li><li>()也可以表示逻辑或 (a|b|c)</li></ul><h5 id="分组捕获"><a href="#分组捕获" class="headerlink" title="分组捕获()"></a>分组捕获()</h5><ul><li>每一个()都是一个组 0代表整个匹配项 分组编号从1开始</li><li>在进行匹配后的操作时可以通过$1 $2拿到匹配到的分组 $0表示整个字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把手机号变成通用的 只保留区号</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(\d&#123;3&#125;)[.-](\d&#123;3&#125;)[.-](\d&#123;4&#125;)/</span></span><br><span class="line"></span><br><span class="line"><span class="string">'212-555-1234'</span>.replace(reg,<span class="string">'$1-xxx-xxxx'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换单词</span></span><br><span class="line"><span class="string">'shiffina, Daniel'</span>.replace(<span class="regexp">/(\w+),\s(\w+)/</span>,<span class="string">'$2, $1'</span>)</span><br></pre></td></tr></table></figure><ul><li>如果在正则里边就拿到匹配的分组 可以通过分组编号拿到</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\b(\w+)\s\1\b/</span>; <span class="comment">//匹配连续的相同的单词</span></span><br><span class="line"></span><br><span class="line"><span class="string">'this is is age'</span>.replace(reg,<span class="string">'$1'</span>) <span class="comment">//this is age</span></span><br></pre></td></tr></table></figure><ul><li>贪婪的<em>，如果使用</em>去匹配 会一直匹配到最后一个</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\[.*\]/</span>;</span><br><span class="line"><span class="string">'[baidu]http://www.baodu.com [google]'</span>.replace(reg,<span class="string">'&lt;h1&gt;&lt;/h1&gt;'</span>) <span class="comment">//&lt;h1&gt;&lt;/h1&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*后边?去掉贪婪模式</span></span><br><span class="line"><span class="keyword">let</span> reg2 = <span class="regexp">/\[.*?\]/</span>;</span><br><span class="line"><span class="string">'[baidu]http://www.baodu.com [google]'</span>.replace(reg2,<span class="string">'&lt;h1&gt;&lt;/h1&gt;'</span>) <span class="comment">//&lt;h1&gt;&lt;/h1&gt;http://www.baodu.com [google]</span></span><br></pre></td></tr></table></figure><h5 id="正则在js中的应用"><a href="#正则在js中的应用" class="headerlink" title="正则在js中的应用"></a>正则在js中的应用</h5><ul><li>reg.test 返回boolean 测试是不是通过正则规则</li><li>str.match 返回匹配到的内容 默认返回第一个 有分组的话数组的第二个元素起就是匹配到的分组</li><li>reg.exec(str) 每次调用，返回一个匹配的结果 匹配结果和分组以数组的形式返回</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Here is a Phone Number 111-2313 and 133-2311"</span> ;</span><br><span class="line"><span class="keyword">var</span> srg = <span class="regexp">/(\d&#123;3&#125;)[-.]\d&#123;4&#125;/g</span>;</span><br><span class="line"><span class="keyword">var</span> result = srg.exec(str);</span><br><span class="line"><span class="keyword">while</span>(result !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    result = srg.exec(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>str.split(str|reg) 按匹配项分割字符串</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[,.?!\s]+/</span>  <span class="comment">//按单词分割</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/([,.?!]+)/</span> <span class="comment">//按句子分割并保留分割符</span></span><br></pre></td></tr></table></figure><ul><li>str.replace(reg,str|fn) 查找替换 返回替换后的值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/&lt;\/?.+?\/?&gt;/g</span> <span class="comment">//匹配所有html标签 支持嵌套</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找出出现次数最多的字符</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'aabbsbaabbabaslld'</span>;</span><br><span class="line"><span class="keyword">var</span> a =  str.split(<span class="string">''</span>).sort().join(<span class="string">''</span>);</span><br><span class="line"><span class="keyword">var</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> char = <span class="string">''</span>;</span><br><span class="line">a.replace(<span class="regexp">/(\w)\1+/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">match,$<span class="number">1</span></span>)</span>&#123;  </span><br><span class="line">  <span class="keyword">if</span>(max&lt;match.length)&#123;</span><br><span class="line">    max = match.length;</span><br><span class="line">    char = match[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> match</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = a.replace(<span class="regexp">/(\w)\1+/g</span>);</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b.length - a.length</span><br><span class="line">&#125;)</span><br><span class="line">max = arr[<span class="number">0</span>].length;</span><br><span class="line">char = arr[<span class="number">0</span>][<span class="number">0</span>];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本规则&quot;&gt;&lt;a href=&quot;#基本规则&quot; class=&quot;headerlink&quot; title=&quot;基本规则&quot;&gt;&lt;/a&gt;基本规则&lt;/h4&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;single char(单字符)&lt;/th&gt;
&lt;th&gt;quantifiers(数量
      
    
    </summary>
    
      <category term="前端知识" scheme="http://webbHou.github.io/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
      <category term="正则" scheme="http://webbHou.github.io/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>hooks的使用和如何定义hooks</title>
    <link href="http://webbHou.github.io/2020/11/17/hooks%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89hooks/"/>
    <id>http://webbHou.github.io/2020/11/17/hooks的使用和如何定义hooks/</id>
    <published>2020-11-17T06:24:34.000Z</published>
    <updated>2021-05-21T09:04:55.433Z</updated>
    
    <content type="html"><![CDATA[<h4 id="常用的一些hooks"><a href="#常用的一些hooks" class="headerlink" title="常用的一些hooks"></a>常用的一些hooks</h4><ul><li>useState：类似class组件的state 用来定义一些状态和变量</li><li>useEffect：副作用操作 可以在依赖值改变时执行一些副作用操作 可以用来模拟一些生命周期操作</li><li>useRef：用来定义一个ref</li><li>useContext：接收一个context 并返回最新的context值 当该组件依赖的Provider.context更新时   该hooks会触发重新渲染</li><li>useReducer: 接受一个reducer和默认state值 返回最新的state和dispatch函数</li><li>useMemo：返回一个值，当依赖项改变时重新计算</li><li>useCallback：接受一个回调函数和依赖数组，返回一个回调函数，该函数可以在依赖项改变时更新 回调会手动调用  普通函数不会更新</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt;</span><br><span class="line">      &lt;Toolbar /&gt;</span><br><span class="line">    &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemedButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function ThemedButton() &#123;</span></span><br><span class="line"><span class="regexp">  const theme = useContext(ThemeContext);</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      I am styled by theme context!</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何自定义一个hooks"><a href="#如何自定义一个hooks" class="headerlink" title="如何自定义一个hooks"></a>如何自定义一个hooks</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//监听网络状态和类型的hooks  </span></span><br><span class="line"><span class="comment">//可以在网络连接变化和类型变化是进行不同的展示和提示 提高用户体验</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">useNetChange</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isConnected, setIsConnected] = useState(<span class="literal">true</span>); <span class="comment">//网络是否连接</span></span><br><span class="line">  <span class="keyword">const</span> [networkType, setNetworkType] = useState(<span class="literal">true</span>); <span class="comment">//网络类型</span></span><br><span class="line">  <span class="keyword">let</span> initStatus = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;  <span class="comment">//第一次进来获取网络状态和类型</span></span><br><span class="line">    Taro.getNetworkType().then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(res.networkType === <span class="string">'none'</span>)&#123;</span><br><span class="line">        setIsConnected(<span class="literal">false</span>)</span><br><span class="line">        initStatus = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      setNetworkType(res.networkType)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cancleNetChange = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">//取消网络变化监听  应用该hooks的组件每次更新后清除 effect 避免执行多次监听函数 导致内存泄漏</span></span><br><span class="line">    Taro.offNetworkStatusChange();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Taro.onNetworkStatusChange(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123; <span class="comment">//监听网络变化</span></span><br><span class="line">    setIsConnected(res.isConnected);</span><br><span class="line">    setNetworkType(res.networkType);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> [isConnected, initStatus, networkType, cancleNetChange]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;常用的一些hooks&quot;&gt;&lt;a href=&quot;#常用的一些hooks&quot; class=&quot;headerlink&quot; title=&quot;常用的一些hooks&quot;&gt;&lt;/a&gt;常用的一些hooks&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;useState：类似class组件的state 用来定义一些状
      
    
    </summary>
    
      <category term="js常见问题" scheme="http://webbHou.github.io/categories/js%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Typescript+工程化</title>
    <link href="http://webbHou.github.io/2020/10/30/Typescript%E5%85%A5%E9%97%A8%E5%92%8C%E5%B7%A5%E7%A8%8B%E5%8C%96%E6%90%AD%E5%BB%BA/"/>
    <id>http://webbHou.github.io/2020/10/30/Typescript入门和工程化搭建/</id>
    <published>2020-10-30T10:47:23.000Z</published>
    <updated>2021-05-21T09:04:55.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Typescript-工程化-text-shadow"><a href="#Typescript-工程化-text-shadow" class="headerlink" title="Typescript+工程化 {.text-shadow}"></a>Typescript+工程化 {.text-shadow}</h3><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h3 id="Typescript"><a href="#Typescript" class="headerlink" title="Typescript"></a>Typescript</h3><ul><li><a href="https://www.tslang.cn/index.html" target="_blank" rel="noopener">简介</a></li><li>基础类型</li><li>高级类型</li><li>接口</li><li>类</li><li>函数</li><li>泛型</li><li>模块</li><li>命名空间</li><li>装饰器</li><li>type &amp; interface</li></ul><h4 id="简介及实用性"><a href="#简介及实用性" class="headerlink" title="简介及实用性"></a>简介及实用性</h4><p>TypeScript的核心原则之一是对值所具有的结构进行类型检查</p><ul><li>接口定义 <a href="https://github.com/alibaba/pont" target="_blank" rel="noopener">pont</a></li><li>类型推断、健壮编码</li></ul><h4 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h4><ul><li>boolean</li><li>number</li><li>string</li><li>array：number[] | Array<number></number></li><li>Tuple元祖：表示已知元素类型和数量的数组</li><li>enum：枚举</li><li>any：未知类型时</li><li>void：没有类型，当一个函数没有返回值时表示   void的类型只能赋值undefined|null</li><li>null和undefined</li><li>Never：永不到达的值</li><li>Object： 非原始类型</li><li>类型断言：已知某值的类型时，跳过检查，更快的编译  <number>Value | Value as string</number></li></ul><h4 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h4><ul><li>交叉类型 &amp;</li><li>联合类型 |</li><li>类型保护：联合类型时为了确切的知道类型时 typeof instanceof 三元表达式</li><li>为null类型：可选参数 可选属性</li><li>类型别名：type</li><li>多态this类型</li><li>索引类型：对函数参数进行限制</li><li>映射类型：把一个对象映射编程想要的接口类型</li></ul><h4 id="接口interface"><a href="#接口interface" class="headerlink" title="接口interface"></a>接口interface</h4><p>接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约{.text-description}</p><ul><li>可选属性：color?：string</li><li>只读属性：readonly length:number</li><li>额外的属性检查：字符串索引签名[props:string]:any</li><li>函数类型：定义参数类型和返回值类型</li><li>可索引：[props:string|number]:type</li><li>继承接口：extend 可以继承多个接口</li><li>继承接口类：当一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）</li><li>对象字面量：会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候</li></ul><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><ul><li>public</li><li>private：不能在类外访问，子类(派生类)也不可访问</li><li>protected：跟private不同在可以在子类中访问</li><li>readonly：只读属性必须在声明时或构造函数里被初始化。</li><li>get/set：TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。</li><li>static：静态属性 必须在使用时加上类名来访问</li><li>abstract：定义抽象类抽象方法 不能进行实例化，包含除抽象方法外方法的实现细节  抽象方法必须在派生类中实现</li><li>把类当做接口使用</li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><ul><li>函数类型：定义函数的参数和返回值类型</li><li>推断类型：根据函数定义的参数和返回值类型 推断出参数类型</li><li>可选参数和默认参数： 不同于js，没有传参就是undefined</li><li>剩余参数：当你不知道有几个参数时 把剩余参数收集到一个变量里</li><li>重载：当参数类型不同 返回值也不同时  可以为同一个函数提供多个函数类型定义来进行函数重载 重载后调用会进行正确的类型检查 其他方式会报错</li></ul><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>类型的可重用性，不仅支持现在的、也要考虑未来的数据类型{.text-description}</p><ul><li>泛型函数：传入的参数类型被捕获 然后就可以使用这个类型</li><li>泛型接口：把泛型参数当作整个接口的一个参数，就可以锁定接口的类型</li><li>泛型类：</li><li>泛型约束：对函数传入的参数进行约定</li></ul><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><ul><li>数字枚举：自增长</li><li>字符串枚举：可以自定义一个有意义的可读值</li></ul><h4 id="类型推断和类型兼容性"><a href="#类型推断和类型兼容性" class="headerlink" title="类型推断和类型兼容性"></a>类型推断和类型兼容性</h4><ul><li>类型推断：在没有明确类型的地方，会推断提供类型</li><li>类型兼容性：赋值的属性必须要在被赋值中找到对应属性</li></ul><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>现在推荐是用命名空间的写法去写{.text-description}</p><ul><li>导入：export default</li><li>导出：import</li><li>声明模块：declare</li></ul><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>当一个类型关联的方法或类越来越多，为了防止于其他对象产生命名冲突，我们需要把他包裹在命名空间内，而不是在全局命名空间下{.text-description}</p><ul><li>namespace: 命名空间内的接口和类如果需要在外部访问 需要export 否则不能被访问</li><li>分离：当代码越来越多时，我们需要把代码进行拆分进行维护，他们还是一个命名空间  只不过在不同文件中  使用时根据依赖关系进行调用</li><li>别名：我们可以用import q = x.y.z给常用的对象起一个短的名字</li><li>其他外部js库：为了描述不是用TypeScript编写的类库的类型，我们用外部命名空间声明 通常在name.d.ts里书写</li></ul><h3 id="声明合并"><a href="#声明合并" class="headerlink" title="声明合并"></a>声明合并</h3><ul><li>合并接口：<ul><li>当一个接口多次被声明时，会被自动合并</li><li>非函数成员：如果声明的非函数成员多次被声明，且类型不同则会报错</li><li>函数成员：每个同名函数声明都会被当成这个函数的一个重载</li></ul></li><li>合并命名空间<ul><li>当一个命名空间多次被声明时，会被自动合并</li><li>非导出成员只在之前的命名空间内可用</li></ul></li><li>命名空间、类、函数、枚举的合并：当两个不同的类型具有相同相同的名称时会被合并，调用时会被查找</li></ul><h5 id="type-amp-interface"><a href="#type-amp-interface" class="headerlink" title="type &amp; interface"></a>type &amp; interface</h5><ul><li>type：类型别名  <ul><li>不仅仅能够表示 object、class、function</li><li>不能重名（自然不存在同名聚合了），扩展已有的 type 需要创建新 type</li><li>支持复杂的类型操作</li><li>联合类型的不能被继承和implements 但可以和interface互相聚合</li></ul></li><li>interface：<ul><li>同名的 interface 自动聚合，也可以跟同名的 class 自动聚合</li><li>只能表示 object、class、function 类型</li><li>可以被继承和implements 可以被拓展  所以尽量使用接口代替类型别名</li></ul></li></ul><h3 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h3><h4 id="开发体验"><a href="#开发体验" class="headerlink" title="开发体验"></a>开发体验</h4><ul><li><a href="https://mp.weixin.qq.com/s/3vYbCV84QE5yJbpIYZdmbw" target="_blank" rel="noopener">cli脚手架</a></li><li><a href="https://mp.weixin.qq.com/s/nuwSW8cAv0izEk4GIofI7w" target="_blank" rel="noopener">UI组件库</a>：<ul><li>文档<a href="https://www.vuepress.cn/config/#%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener">vuepress</a></li><li><a href="https://mp.weixin.qq.com/s/nuwSW8cAv0izEk4GIofI7w" target="_blank" rel="noopener">公共组件、发布npm包</a></li></ul></li><li><a href="https://github.com/alibaba/pont/blob/master/README.md" target="_blank" rel="noopener">前后端合作</a></li></ul><h4 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h4><ul><li>代码规范<ul><li>eslint</li></ul><ul><li>格式规则：可以–fix自动被修复  </li><li>质量规则：可能出现的bug 不能被二次自动修复 需要prettier去处理格式</li></ul><ul><li>prettier<br>typescript</li></ul></li><li>测试：jest</li><li>husky：哈士奇</li><li>git-hooks：git钩子<ul><li>pre-commit</li><li>commit-msg</li><li>pre-receive</li><li>post-receive</li></ul></li><li>commitlint：git提交规范</li><li>lint-staged：只检测暂存区代码</li></ul><h4 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h4><ul><li>加载优化</li><li>渲染优化</li></ul><h5 id="加载优化"><a href="#加载优化" class="headerlink" title="加载优化"></a>加载优化</h5><ul><li>文件大小：webpack打包：<code>/** @type {import(&#39;webpack&#39;).Configuration} */</code></li><li>并发限制：CDN、合并请求、http2.0</li><li>缓存：浏览器缓存、DNS缓存、服务器缓存、数据持久化</li><li>前端监控：埋点或错误上报</li><li>预加载：强依赖包进行预加载</li><li>http1/2：1.0-&gt;1.1 keep alive、断点续传、缓存-&gt;2.0二进制传输、多路复用、服务端push</li></ul><h5 id="渲染优化"><a href="#渲染优化" class="headerlink" title="渲染优化"></a>渲染优化</h5><ul><li>预渲染、预解析、懒加载</li><li>按需加载</li><li>SSR</li><li>vdom:减少回流重回操作</li></ul><h4 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h4><ul><li>https<ul><li>相比http多了层TLS协议，相对安全</li></ul></li><li>XSS攻击<ul><li>跨站脚本：利用浏览器的输入输出漏洞进行脚本攻击</li></ul></li><li>CSRFF<ul><li>跨站伪装请求：访问第三方站点时，利用用户的登录态调取接口</li></ul></li></ul><h5 id="https"><a href="#https" class="headerlink" title="https"></a>https</h5><ul><li>非对称加密：有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</li><li>对称加密：对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</li><li>TLS协议：传输层和应用层之间，相对http耗时，需要3次握手过程</li><li>TLS握手：<ul><li>客户端发送一个随机值，需要的协议和加密方式</li><li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密</li></ul></li><li>传输：对称加密(TLS握手生成的秘钥进行加密解密)</li></ul><h5 id="XSS攻击-跨站脚本"><a href="#XSS攻击-跨站脚本" class="headerlink" title="XSS攻击:跨站脚本"></a>XSS攻击:跨站脚本</h5><ul><li><p>危害</p><ul><li>窃取cookie信息</li><li>监听用户行为</li><li>修改dom，伪造登录页面</li></ul></li><li><p>类型</p><ul><li>存储型：黑客输入脚本然后存入该站点数据库，用户访问时请求就包含了恶意脚本，执行就会被窃取用户信息</li><li>反射型：该类型不需要存储在数据库，恶意链接会携带js脚本，然后在页面中执行，触发恶意操作</li><li>基于DOM：通过手段修改dom，html传输中或使用中被劫持，然后修改dom</li></ul></li><li><p>防范</p><ul><li>重要数据httpOnly</li><li>对页面上的输入和输出内容进行转义或过滤</li><li>利用CSP（同源策略）：禁止加载或者执行其他域下的脚本</li></ul></li></ul><h5 id="CSRF：跨站伪装请求"><a href="#CSRF：跨站伪装请求" class="headerlink" title="CSRF：跨站伪装请求"></a>CSRF：跨站伪装请求</h5><ul><li><p>危害</p><ul><li>窃取cookie信息</li><li>伪装请求来让操作用户数据或财产</li></ul></li><li><p>类型</p><ul><li>伪造get请求（img\src等标签自动发起请求）</li><li>伪造post请求（表单自动提交）</li><li>吸引用户点击第三方站点链接</li></ul></li><li><p>防范</p><ul><li>get 不修改数据</li><li>禁止第三方网站发送cookie：设置cookit的sameSite（Strict|Lax|None）</li><li>CSRF Token：第一次请求下发CSRF Token、接口请求携带并校验</li></ul><ul><li>设置白名单，不被第三方请求</li></ul><ul><li>请求来源校验（origin、refer：安全原因有时候没有）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Typescript-工程化-text-shadow&quot;&gt;&lt;a href=&quot;#Typescript-工程化-text-shadow&quot; class=&quot;headerlink&quot; title=&quot;Typescript+工程化 {.text-shadow}&quot;&gt;&lt;/a&gt;Types
      
    
    </summary>
    
      <category term="前端" scheme="http://webbHou.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="typescript" scheme="http://webbHou.github.io/tags/typescript/"/>
    
      <category term="工程化" scheme="http://webbHou.github.io/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>egg入门和实践</title>
    <link href="http://webbHou.github.io/2020/10/24/egg%E5%85%A5%E9%97%A8%E5%92%8C%E5%AE%9E%E8%B7%B5/"/>
    <id>http://webbHou.github.io/2020/10/24/egg入门和实践/</id>
    <published>2020-10-24T11:00:13.000Z</published>
    <updated>2021-05-21T09:04:55.433Z</updated>
    
    <content type="html"><![CDATA[<h4 id="egg和koa的区别"><a href="#egg和koa的区别" class="headerlink" title="egg和koa的区别"></a>egg和koa的区别</h4><ul><li>api上：更好的封装，使开发人员只注重于业务而不需要原理，更简单方便的去写业务</li><li>脚手架：<ul><li>文件分割：根据controller、service、config去存放和管理，便于后期维护</li><li>ts支持：会自动生成相关文件的d.ts类型文件，存放于typings文件夹下，与业务目录形成映射</li><li>test、eslint、log支持</li></ul></li><li>插件系统：强大的插件系统让你可以直接使用第三方插件，配置简单</li><li>configs：根据环境进行区分，可以配置不同环境的数据和参数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;egg和koa的区别&quot;&gt;&lt;a href=&quot;#egg和koa的区别&quot; class=&quot;headerlink&quot; title=&quot;egg和koa的区别&quot;&gt;&lt;/a&gt;egg和koa的区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;api上：更好的封装，使开发人员只注重于业务而不需要原理，更简单
      
    
    </summary>
    
      <category term="nodejs" scheme="http://webbHou.github.io/categories/nodejs/"/>
    
    
      <category term="egg" scheme="http://webbHou.github.io/tags/egg/"/>
    
      <category term="nodejs" scheme="http://webbHou.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>readux异步操作及react-thunk中间件原理解析</title>
    <link href="http://webbHou.github.io/2020/10/19/readux%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E5%8F%8Areact-thunk%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <id>http://webbHou.github.io/2020/10/19/readux异步操作及react-thunk中间件原理解析/</id>
    <published>2020-10-19T10:55:11.000Z</published>
    <updated>2021-05-21T09:04:55.436Z</updated>
    
    <content type="html"><![CDATA[<h5 id="redux的异步操作是怎么进行的"><a href="#redux的异步操作是怎么进行的" class="headerlink" title="redux的异步操作是怎么进行的"></a>redux的异步操作是怎么进行的</h5><p>用过redux的应该都知道，redux的工作流是同步的过程，用户在页面触发动作dispatch一个action，然后被分配到对应的reducer，然后根据action的type进行同步的处理，然后更新store，subscribe监控store的改变对页面的state进行更新。</p><p>action必须要由dispatch去发起，还有action必须返回object，所以如果一个异步操作需要进行，有下面两种方式：</p><ul><li>闭包：改写dispatch可以接受一个函数，函数执行返回一个异步函数，在异步完成后进行dispatch的调用。但是dispatch不是全局变量，所以需要进行保存，所以用闭包的方式进行保存，来保证异步完成后可以去dispatch，这就是Redux-thunk的做法。</li><li>监听action：一般的流程是dispatch后的action会进入reducer，但是reducer是同步操作，所以我们需要去监听这个action异步处理后再发起真正的action，redux-saga就是这样的原理。</li></ul><h5 id="为什么要使用chunk"><a href="#为什么要使用chunk" class="headerlink" title="为什么要使用chunk"></a>为什么要使用chunk</h5><p>上边说过我们可以在异步完成后去disptach一个action，所以我们可以这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.props.dispatch(action)</span><br><span class="line">&#125;,<span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>但是当我们需要大量的重复操作，我们需要给每一个发出异步的组件都必须注入dispatch，还需要去区分同步还是异步的操作。还有的甚至还需要逻辑操作，需要获取state。这样以后就变得很难维护。所以在thunk中我们直接将dispatch和getState注入到返回的函数参数中，直接可以使用。</p><h5 id="redux-thunk原理"><a href="#redux-thunk原理" class="headerlink" title="redux-thunk原理"></a>redux-thunk原理</h5><p>上边说到通过改造dispatch方法接受一个函数，然后运用闭包的方式在函数执行结束后去dispatch一个action。</p><h6 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'INCREMENT'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incrementAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch,getState</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      dispatch(increment()); <span class="comment">//异步操作</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> store.dispatch(incrementAsync);</span><br></pre></td></tr></table></figure><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thunk</span>(<span class="params">store</span>) </span>&#123;  <span class="comment">//一个中间件首先接受一个store</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>&#123;  <span class="comment">//然后接受一个next 类似express的中间件 洋葱模型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123; <span class="comment">//真正的action</span></span><br><span class="line">      <span class="keyword">const</span> &#123; dispatch, getState &#125; = store;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;  <span class="comment">//如果是函数则先去执行  再去发起真正的action</span></span><br><span class="line">        <span class="keyword">return</span> action(dispatch, getState);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> result = next(action); <span class="comment">//普通action会进入next 按洋葱模型的方式 去到下一个中间件被处理 最后被返回</span></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="额外的参数"><a href="#额外的参数" class="headerlink" title="额外的参数"></a>额外的参数</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk.withExtraArgument(&#123; api, whatever &#125;)),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchUser</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState, &#123; api, whatever &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 现在你可以使用这个额外的参数api和whatever了</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们需要给thunk一个额外的方法去接受参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">thunk</span>(<span class="params">store</span>) </span>&#123;  <span class="comment">//一个中间件首先接受一个store</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">next</span>) </span>&#123;  <span class="comment">//然后接受一个next 类似express的中间件 洋葱模型</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">action</span>) </span>&#123; <span class="comment">//真正的action</span></span><br><span class="line">        <span class="keyword">const</span> &#123; dispatch, getState &#125; = store;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;  <span class="comment">//如果是函数则先去执行  再去发起真正的action</span></span><br><span class="line">          <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> result = next(action); <span class="comment">//普通action会进入next 按洋葱模型的方式 去到下一个中间件被处理 最后被返回</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br></pre></td></tr></table></figure><p>最后放出官方源码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> next(action);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware();</span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;redux的异步操作是怎么进行的&quot;&gt;&lt;a href=&quot;#redux的异步操作是怎么进行的&quot; class=&quot;headerlink&quot; title=&quot;redux的异步操作是怎么进行的&quot;&gt;&lt;/a&gt;redux的异步操作是怎么进行的&lt;/h5&gt;&lt;p&gt;用过redux的应该都知道，
      
    
    </summary>
    
      <category term="js常见问题" scheme="http://webbHou.github.io/categories/js%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程的意义和实践</title>
    <link href="http://webbHou.github.io/2020/09/12/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E6%84%8F%E4%B9%89%E5%92%8C%E5%AE%9E%E8%B7%B5/"/>
    <id>http://webbHou.github.io/2020/09/12/函数式编程的意义和实践/</id>
    <published>2020-09-12T02:59:56.000Z</published>
    <updated>2021-05-21T09:04:55.437Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h3><p>跟面向对象一样，函数式编程也是一种编程范式，它更专注于面向结果，目标更清晰，如何去用更少的代码去实现结果。很多可能会诟病它实现中的代码结构混乱，函数过于零散等问题，但那是因为没有深入了解，函数式编程也有自己的编程规范，让你的代码更易于维护和结构清晰，让你逐渐养成更良好的编程习惯，减少太多垃圾无用的代码。相信你学习后再回去看你写的代码你会变得苛刻。</p><h3 id="为什么需要函数式编程"><a href="#为什么需要函数式编程" class="headerlink" title="为什么需要函数式编程"></a>为什么需要函数式编程</h3><p>众所周知，面向对象的编程一直在被大力吹嘘，但是你们没发现有时候我们为了实现一个简单的功能写了太多无用的代码，需要考虑的更多，束缚也更多。<br>而在函数编程里我们更能清晰的知道需要做什么，怎么更简单去实现，如何写更少的代码去完成，让后期更好去维护和理解。所以相对于面对对象的方式，我更乐于用函数式编程的方式去实现。</p><h3 id="函数式编程的几个概念"><a href="#函数式编程的几个概念" class="headerlink" title="函数式编程的几个概念"></a>函数式编程的几个概念</h3><ul><li>纯函数： 纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">看一个例子</span><br><span class="line"></span><br><span class="line">slice：固定的输入，会返回相同的结果，而不会改变源数据</span><br><span class="line">const arr = [1,4,5,3,2,6,8];</span><br><span class="line">arr.slice(0,3); //[1,4,5]</span><br><span class="line">arr.slice(0,3); //[1,4,5]</span><br><span class="line"></span><br><span class="line">splice：会改变源数据，每次调用都会出现不同结果</span><br><span class="line">const arr = [1,4,5,3,2,6,8];</span><br><span class="line">arr.splice(0,3); //[1,4,5]</span><br><span class="line">arr.splice(0,3); //[3,2,6]</span><br><span class="line"></span><br><span class="line">//所以在函数编程中我们更喜欢没有任何副作用的纯函数，不会再调用中引发任何不可预知的错误</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是函数式编程&quot;&gt;&lt;a href=&quot;#什么是函数式编程&quot; class=&quot;headerlink&quot; title=&quot;什么是函数式编程&quot;&gt;&lt;/a&gt;什么是函数式编程&lt;/h3&gt;&lt;p&gt;跟面向对象一样，函数式编程也是一种编程范式，它更专注于面向结果，目标更清晰，如何去用更少的代
      
    
    </summary>
    
      <category term="学习" scheme="http://webbHou.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
      <category term="函数式编程" scheme="http://webbHou.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法</title>
    <link href="http://webbHou.github.io/2020/07/16/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://webbHou.github.io/2020/07/16/数据结构与算法/</id>
    <published>2020-07-16T05:49:57.000Z</published>
    <updated>2021-05-21T09:04:55.440Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要学习数据结构"><a href="#为什么要学习数据结构" class="headerlink" title="为什么要学习数据结构"></a>为什么要学习数据结构</h4><p>很多前端人说数据结构和算法在工作中根本用不到，但是为什么在大厂面试中算法是必考的一个环节呢，我认为熟练掌握必备的数据结构和算法是在个人提升和技术进阶的必要一部分，1.首先能让你更好的阅读源码的设计理念和架构原理。2.在工作中也能根据不同业务来选择合适的技术方案，知道不同技术的利弊和权衡点，成为技术选型的参与者而不是旁观者。3.提升自己的项目视野和架构能力，而不是仅仅只局限于业务层面，而数据结构和算法是架构能力的基石。4.进阶大厂，了解技术的多样性和认识更加优秀的同伴。</p><h4 id="什么是数据结构与算法"><a href="#什么是数据结构与算法" class="headerlink" title="什么是数据结构与算法"></a>什么是数据结构与算法</h4><ul><li>数据结构：广义上来说就是一组数据的存储结构，比如图书馆所有书籍一般按类别来摆放，按照规律进行编号存储。</li><li>算法：就是这组数据的操作方法，找一本书，你可以一本一本去找，也可以按照类别去找，或者按照编号去找，这些方法都属于算法。</li></ul><h4 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h4><ul><li>时间复杂度：一个程序执行消耗的时间，等执行次数趋于无限大时，常数被忽略不计，T(n) = O(n)</li><li>空间复杂度：一个程序执行所占用的内存空间，</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//出现次数最多的字符</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'aboocdfhhg'</span>;</span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">str.replace(<span class="regexp">/(.)/</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log($<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">if</span>(a[$<span class="number">2</span>])&#123;</span><br><span class="line">    a[$<span class="number">2</span>] += <span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    a[$<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> $<span class="number">4.</span>slice(<span class="number">0</span>,$<span class="number">3</span>).indexOf($<span class="number">2</span>)!==<span class="number">-1</span>?<span class="string">''</span>:$<span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最长不重复</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'aboocdfhhg'</span>;</span><br><span class="line"><span class="keyword">let</span> max = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">  <span class="keyword">let</span> num = str[i];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j=i+<span class="number">1</span>;j&lt;str.length;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.slice(i,j).indexOf(str[j]) === <span class="number">-1</span>)&#123;</span><br><span class="line">      num = num + str[j];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      max = max.length&gt;num.length?max:num;</span><br><span class="line">      num = <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  max = max.length&gt;num.length?max:num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要学习数据结构&quot;&gt;&lt;a href=&quot;#为什么要学习数据结构&quot; class=&quot;headerlink&quot; title=&quot;为什么要学习数据结构&quot;&gt;&lt;/a&gt;为什么要学习数据结构&lt;/h4&gt;&lt;p&gt;很多前端人说数据结构和算法在工作中根本用不到，但是为什么在大厂面试中算法是必
      
    
    </summary>
    
      <category term="计算机基础" scheme="http://webbHou.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机基础" scheme="http://webbHou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
      <category term="算法" scheme="http://webbHou.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://webbHou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>flutter学习及实践</title>
    <link href="http://webbHou.github.io/2020/07/13/flutter%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%AE%9E%E8%B7%B5/"/>
    <id>http://webbHou.github.io/2020/07/13/flutter学习及实践/</id>
    <published>2020-07-13T06:50:47.000Z</published>
    <updated>2021-05-21T09:04:55.433Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>String、Number、Null、Map、List、Symble、弱类型(var、object、dynamic)</p><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><ul><li>??：0??1相当于0?0:1</li><li>联级操作：允许一个对象或函数进行一系列操作，比如一个对象有多个方法可以进行依次调用</li></ul><h4 id="类和构造函数"><a href="#类和构造函数" class="headerlink" title="类和构造函数"></a>类和构造函数</h4><ul><li>构造函数：一个类可以有多个构造函数，在实例化时可以选择调用</li><li>抽象类：关键字abstract声明，实现一个类被用于其他子类继承，抽象类是无法实例化的</li><li>泛型类：不确定返回数据结构时使用，class Array<t></t></li></ul><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><ul><li>public(默认)</li><li>私有：则在方法或者属性名前使用“_”</li></ul><h4 id="库调用"><a href="#库调用" class="headerlink" title="库调用"></a>库调用</h4><p>import ‘package:startup_namer/pages/homepage.dart’;</p><p>import 为关键词，package 为协议，可以使用 http 的方式，不过最好使用本地 package 方式。</p><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>先微任务再事件任务，dart线程不共享变量，线程间通过消息机制传递信息。</p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>isolate</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h3&gt;&lt;p&gt;String、Number、Null、Map、List、Symble、弱类型(var、object、dynamic)&lt;/p&gt;
      
    
    </summary>
    
      <category term="学习" scheme="http://webbHou.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
      <category term="flutter" scheme="http://webbHou.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>node做中间层的优势和必要</title>
    <link href="http://webbHou.github.io/2020/07/09/node%E5%81%9A%E4%B8%AD%E9%97%B4%E5%B1%82%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%BF%85%E8%A6%81/"/>
    <id>http://webbHou.github.io/2020/07/09/node做中间层的优势和必要/</id>
    <published>2020-07-09T09:04:23.000Z</published>
    <updated>2021-05-21T09:04:55.435Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么用Node-js搭建中间层"><a href="#为什么用Node-js搭建中间层" class="headerlink" title="为什么用Node.js搭建中间层"></a>为什么用Node.js搭建中间层</h3><h4 id="什么是中间层"><a href="#什么是中间层" class="headerlink" title="什么是中间层"></a>什么是中间层</h4><p>在翻看很多技术文章时，大家都提到“中间层”，在很多大型企业中，Node确实承担了“中间层”的角色，那么，Node为什么被广泛的应用在“中间层”呢？</p><p>要回答这个问题，先来陈述下什么是中间层。</p><p>通常我们把Web领域分为客户端和服务端，也就是前端和后端，这里的后端就包含了网关，静态资源，接口，缓存，数据库等。而中间层呢，就是在后端这里再抽离一层出来，在业务上处理和客户端衔接更紧密的部分，比如页面渲染（SSR），数据聚合，接口转发等等。</p><p>以SSR来说，在服务端将页面渲染好，可以加快用户的首屏加载速度，避免请求时白屏，还有利于网站做SEO，他的好处是比较好理解的。那么对于数据的聚合，接口转发来说，这样做有什么意义呢？</p><h4 id="用Node的4点意义"><a href="#用Node的4点意义" class="headerlink" title="用Node的4点意义"></a>用Node的4点意义</h4><h5 id="业务驱动"><a href="#业务驱动" class="headerlink" title="业务驱动"></a>业务驱动</h5><p>Node有个突出的优势，他的开发者可以是前端。</p><p>前端对于页面所需要的数据有更好的理解，每个页面要用到哪些接口，每个接口要用到哪些字段前端是最清楚的。再加上实际业务开发中，前端页面需求经常会发生变化，需要修改字段或者数据结构，所以对接页面的这部分接口由前端直接开发非常合适，尤其配合GraphQL可以只关注于业务，字段和数据结构直接由前端定义，可以显著的减少沟通成本。</p><h5 id="架构需要"><a href="#架构需要" class="headerlink" title="架构需要"></a>架构需要</h5><p>面向用户的接口由Node中间层负责以后，真正的服务端可以专注于提供基于领域模型的对内接口，做微服务。</p><p>比如可以基于Goods模型，提供所有商品相关的接口；基于Users模型，提供所有用户相关接口。当一个接口需要商品+用户信息时，由Node分别查询组装。从整体业务代码维护角度来说，变得更容易，不会因为业务发展使得每个接口都异常繁杂。</p><h5 id="性能满足"><a href="#性能满足" class="headerlink" title="性能满足"></a>性能满足</h5><p>如果仅仅是架构层面的需求，需要有一个中间层来沉淀业务，那用Java，PHP也可以做到，为什么说Node更适合做呢？</p><p>因为Node天生异步！</p><p>众所周知，js是一门单线程语言，所以Node在实现的时候，需要借助libuv来实现异步。</p><p>如图所示，libuv为Node提供了线程池，事件池，异步I/O等能力。正是因为其中网络I/O的异步能力，可以让Node做接口聚合时，能够更高效的异步并发处理。</p><h5 id="成本较低"><a href="#成本较低" class="headerlink" title="成本较低"></a>成本较低</h5><p>Node使用js开发，只需要学习简单的api，前端开发者就可以无障碍使用，学习成本很低。</p><p>而且，Node具有活跃的社区和丰富的模块池，拥有很多现成的功能实现。框架方面，也有成熟的koa，express等基本框架和egg等二次封装框架，可根据需求选择上手也比较方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么用Node-js搭建中间层&quot;&gt;&lt;a href=&quot;#为什么用Node-js搭建中间层&quot; class=&quot;headerlink&quot; title=&quot;为什么用Node.js搭建中间层&quot;&gt;&lt;/a&gt;为什么用Node.js搭建中间层&lt;/h3&gt;&lt;h4 id=&quot;什么是中间层&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="nodejs" scheme="http://webbHou.github.io/categories/nodejs/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
      <category term="node" scheme="http://webbHou.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>跨端技术的发展和历程</title>
    <link href="http://webbHou.github.io/2020/07/01/%E8%B7%A8%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E5%8E%86%E7%A8%8B/"/>
    <id>http://webbHou.github.io/2020/07/01/跨端技术的发展和历程/</id>
    <published>2020-07-01T02:44:18.000Z</published>
    <updated>2021-05-21T09:04:55.442Z</updated>
    
    <content type="html"><![CDATA[<h4 id="跨端技术的历程和优缺点"><a href="#跨端技术的历程和优缺点" class="headerlink" title="跨端技术的历程和优缺点"></a>跨端技术的历程和优缺点</h4><h5 id="Cordova"><a href="#Cordova" class="headerlink" title="Cordova"></a>Cordova</h5><ul><li>原理：原生技术封装成接口能力通过JSBridge(桥连)方式供js应用调用</li><li>缺点：可拓展操作性少，不可调用底层能力，性能体验较差</li></ul><h5 id="Weex-RN"><a href="#Weex-RN" class="headerlink" title="Weex RN"></a>Weex RN</h5><ul><li>原理：把js业务代码封装成原生组件供原生应用调用</li><li>缺点：需要跟原生不断通信，有很大的性能损耗</li></ul><h5 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h5><ul><li>原理：内置自渲染引擎，所以性能体验较好</li><li>缺点：新的语言语法，学习成本较大</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;跨端技术的历程和优缺点&quot;&gt;&lt;a href=&quot;#跨端技术的历程和优缺点&quot; class=&quot;headerlink&quot; title=&quot;跨端技术的历程和优缺点&quot;&gt;&lt;/a&gt;跨端技术的历程和优缺点&lt;/h4&gt;&lt;h5 id=&quot;Cordova&quot;&gt;&lt;a href=&quot;#Cordova&quot; c
      
    
    </summary>
    
      <category term="js常见问题" scheme="http://webbHou.github.io/categories/js%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>前端应该了解的http知识</title>
    <link href="http://webbHou.github.io/2020/04/10/%E5%89%8D%E7%AB%AF%E5%BA%94%E8%AF%A5%E4%BA%86%E8%A7%A3%E7%9A%84http%E7%9F%A5%E8%AF%86/"/>
    <id>http://webbHou.github.io/2020/04/10/前端应该了解的http知识/</id>
    <published>2020-04-10T09:58:41.000Z</published>
    <updated>2021-05-21T09:04:55.437Z</updated>
    
    <content type="html"><![CDATA[<h5 id="协议：数据传输格式的规范"><a href="#协议：数据传输格式的规范" class="headerlink" title="协议：数据传输格式的规范"></a>协议：数据传输格式的规范</h5><h5 id="http协议：超文本传输协议，无状态协议，没有记忆功能，属于应用层"><a href="#http协议：超文本传输协议，无状态协议，没有记忆功能，属于应用层" class="headerlink" title="http协议：超文本传输协议，无状态协议，没有记忆功能，属于应用层"></a>http协议：超文本传输协议，无状态协议，没有记忆功能，属于应用层</h5><h4 id="Tcp协议"><a href="#Tcp协议" class="headerlink" title="Tcp协议"></a>Tcp协议</h4><ul><li>http的底层协议，属于传输层，跟http一样是无连接协议，将两端连接起来，实际上只是两端维护了一个状态。</li><li>全双工协议，需要确保双方都能接受和发送数据，所以需要三次握手和四次挥手。</li><li>连接中任意一方掉线都会重新开始连接，一般会重连5次。这也是它是无状态的原因。</li></ul><h4 id="简单请求和非简单请求"><a href="#简单请求和非简单请求" class="headerlink" title="简单请求和非简单请求"></a>简单请求和非简单请求</h4><p><strong>非简单请求会在真正请求前发送一个预检请求，options，以获知服务器是否允许该实际请求。</strong>但会浪费时间和性能，所以需要减少和避免。</p><h6 id="以下为非简单请求"><a href="#以下为非简单请求" class="headerlink" title="以下为非简单请求"></a>以下为非简单请求</h6><ul><li>请求方式不属于GET、POST、HEAD</li><li>不得人为设置其他首部字段</li><li>Content-type值不属于：application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul><h4 id="http的general-header"><a href="#http的general-header" class="headerlink" title="http的general header"></a>http的general header</h4><ul><li>Request URL：请求资源地址</li><li>Request Method: GET</li><li>Status Code: 状态码</li></ul><h4 id="http请求格式"><a href="#http请求格式" class="headerlink" title="http请求格式"></a>http请求格式</h4><ul><li><p>请求头：</p><ul><li>Accept-Encoding: 可以兼容的压缩格式</li><li>host：请求主机</li><li>origin：请求源，可以用于服务端设置请求白名单</li><li>Referer：请求页的地址</li><li>Accept-language：请求目标语言</li><li>user-agent：浏览器的版本和客户端系统</li><li>content-type：post请求独有的请求头</li></ul></li><li><p>请求体：</p><ul><li>post：独有的请求体</li><li>get：拼接在地址栏中</li></ul></li></ul><h4 id="http响应格式"><a href="#http响应格式" class="headerlink" title="http响应格式"></a>http响应格式</h4><ul><li><p>响应头：</p><ul><li>Access-Control-Allow-Methods: 允许的请求方式</li><li>Access-Control-Allow-Origin: 允许的请求源</li><li>Content-Type: 响应体文档类型和编码格式</li><li>Date: 时间</li><li>ETag: 文件唯一标识</li><li>cache-control: 最大缓存过期时间（秒）</li><li>expires：缓存过期时间（date格式）</li><li>Last-Modified：最后一次文件修改时间</li><li>content-encoding： 压缩格式</li></ul></li><li><p>响应体</p></li></ul><h4 id="TLS协议"><a href="#TLS协议" class="headerlink" title="TLS协议"></a>TLS协议</h4><ul><li>位于传输层和应用层之间，</li></ul><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><ul><li>进程：一个进程下可能有多个线程，线程运行与进程之下，不能单独存在 不用进程之间数据很难共享 也不会相互影响 进程需要的资源由计算机系统分配</li><li>线程：线程之间共享同一个进程的资源，一个线程挂掉会导致整个进程挂掉。进程使用的内存可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。</li></ul><p>做个简单的比喻：进程=火车，线程=车厢线程在进程下行进（单纯的车厢无法运行）一个进程可以包含多个线程（一辆火车可以有多个车厢）不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－”互斥锁”进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”</p><h4 id="keep-alive和多路复用"><a href="#keep-alive和多路复用" class="headerlink" title="keep-alive和多路复用"></a>keep-alive和多路复用</h4><ul><li>keep-alive: http1.0之前，每次请求都会有创建Tcp连接，三次握手，服务器响应和断开连接四个过程，当请求数变多时就会导致性能被极大的浪费，所有1.0引入了keep-alive(长连接)，1.0需要手动开启，1,1是默认开启的，长连接每次请求后不立即断开连接，会有一个延时等待时间，这期间同一客户端向服务器发送请求都会复用该 TCP 连接，接着重置延时等待时间，这样大大的节省了重复连接和断开的损耗。  </li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeout 时间到了之后，TCP会立即断开连接吗？</span><br><span class="line">若两小时（timeout）没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔 75 秒发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。</span><br></pre></td></tr></table></figure><ul><li><p>那为什么要引入多路复用呢？</p></li><li><p>keep-alive依赖于上一次请求的响应，如果上一次请求被阻塞就会导致，整个后边的请求都会被阻塞。</p></li><li><p>人们采取了很多方法去解决，只是通过减少请求数的方式去进行优化。将同一个请求分散到不同域名下，开启了多个 TCP 连接，或者合并请求。例如使用多个域名、引入雪碧图、将小图内联等，但都没有从根本上解决问题。</p></li><li><p>多路复用</p></li><li><p>2.0提出了多路复用的机制，引入了帧和流，因为 <strong>HTTP/1.x 是基于文本的，因为是文本，就导致了它必须是个整体，在传输是不可切割的，只能整体去传</strong>。</p></li><li>HTTP/2 是基于二进制流的，它就可以把 HTTP 消息分解为独立的帧，交错发送，然后在另一端通过帧中的标识重新组装，这就是多路复用</li><li>就实现了在同一个TCP连接中，同一时刻可以发送多个请求和响应，且不用按照顺序一一对应，即使某个请求任务耗时严重，也不会影响到其它连接的正常执行</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;协议：数据传输格式的规范&quot;&gt;&lt;a href=&quot;#协议：数据传输格式的规范&quot; class=&quot;headerlink&quot; title=&quot;协议：数据传输格式的规范&quot;&gt;&lt;/a&gt;协议：数据传输格式的规范&lt;/h5&gt;&lt;h5 id=&quot;http协议：超文本传输协议，无状态协议，没有记忆
      
    
    </summary>
    
      <category term="学习" scheme="http://webbHou.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="计算机基础" scheme="http://webbHou.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>React-redux高阶组件connect模拟实现</title>
    <link href="http://webbHou.github.io/2019/06/22/React-redux%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6connect%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://webbHou.github.io/2019/06/22/React-redux高阶组件connect模拟实现/</id>
    <published>2019-06-22T05:55:29.000Z</published>
    <updated>2021-05-21T09:04:55.432Z</updated>
    
    <content type="html"><![CDATA[ <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 模拟connect</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">import React,&#123; Component &#125; from <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line">import &#123; PropTypes &#125; from <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const connect = (mapStateToProps,mapDispatchToprops) =&gt; (Wrapcompont) =&gt;&#123;</span><br><span class="line">    <span class="built_in">return</span> class extends Component&#123;</span><br><span class="line">        state=&#123;</span><br><span class="line">            allprops:&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        static contextTypes = &#123;</span><br><span class="line">            store: PropTypes.object</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">componentDidMount</span></span>()&#123;</span><br><span class="line">            const store = this.context.store;</span><br><span class="line">            console.log(this.context)</span><br><span class="line">            this._update();</span><br><span class="line">            store.subscribe(() =&gt; this._update());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //数据更新页面更新</span><br><span class="line">        <span class="function"><span class="title">_update</span></span>()&#123;</span><br><span class="line">            const store = this.context.store;</span><br><span class="line">            const state = mapStateToProps?mapStateToProps(store.getState()):&#123;&#125;;</span><br><span class="line">            const dispatch = mapDispatchToprops?mapDispatchToprops(store.dispatch):&#123;&#125;;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                allprops:&#123;...state,...dispatch,...this.props&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">            <span class="built_in">return</span> &lt;Wrapcompont &#123;...this.state.allprops&#125; /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default connect</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
         &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="js常见问题" scheme="http://webbHou.github.io/categories/js%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>单页面应用路由原理与实现浅析</title>
    <link href="http://webbHou.github.io/2019/05/16/%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%BA%94%E7%94%A8%E8%B7%AF%E7%94%B1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%9E%90/"/>
    <id>http://webbHou.github.io/2019/05/16/单页面应用路由原理与实现浅析/</id>
    <published>2019-05-16T02:15:13.000Z</published>
    <updated>2021-05-21T09:04:55.438Z</updated>
    
    <content type="html"><![CDATA[<p>在现代前端单页面应用中，路由已经变得越来越必不可少。路由描述了url和UI之间的映射关系，这种映射是单向的，即url的变化引发UI的变化。</p><h4 id="如何实现前端路由"><a href="#如何实现前端路由" class="headerlink" title="如何实现前端路由"></a>如何实现前端路由</h4><p>  <strong>实现前端路由，需要解决下面两个核心问题</strong></p><ul><li>改变url如何使页面不刷新？</li><li>如何检测url的变化？</li></ul><h4 id="hash模式实现"><a href="#hash模式实现" class="headerlink" title="hash模式实现"></a>hash模式实现</h4><ul><li>hash是url地址中#及后面的部分，hash值的改变不会导致页面的重载</li><li>需要来监听hashchange事件来渲染不同的页面组件</li></ul><h4 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h4><ul><li>通过history.pushState/history.replaceState 来进行路由的修改</li><li>监听popstate来进行不同组件的渲染</li></ul><h4 id="vuex工作流"><a href="#vuex工作流" class="headerlink" title="vuex工作流"></a>vuex工作流</h4><p>1.new vuex.store({<br>  strtic:true //严格<br>  state：{ }  //全局唯一<br>  mutation：{<br>    add(state,arg){<br>      state+=1;<br>    }<br>  }  //进行state修改<br>  action：{ //提交action到mutaion<br>    addAction({commit},arg){<br>      commit(mutaion名，arg)<br>    }<br>  }，<br>  getter：{ //获取state<br>    getCount(state){</p><pre><code>}</code></pre><p>  }<br>})</p><p>2.页面使用</p><ul><li>提交action  this.$store.disptch(action名，arg)</li><li>使用state   this.$store.state</li></ul><h4 id="vue父子通讯"><a href="#vue父子通讯" class="headerlink" title="vue父子通讯"></a>vue父子通讯</h4><ul><li>props  父-&gt;子  $emit/$on</li><li>新vue实例做中介  $emit/$on</li><li>this.$attrs/$listeners   未继承的属性/方法</li><li>vuex 全局状态共享 this.$store.state</li></ul><h4 id="vue组件"><a href="#vue组件" class="headerlink" title="vue组件"></a>vue组件</h4><ul><li>watch  自动计算  方法名对应绑定变量名</li><li>comuted：  计算</li><li>method： 方法   手动绑定</li></ul><h4 id="vue生命周期钩子"><a href="#vue生命周期钩子" class="headerlink" title="vue生命周期钩子"></a>vue生命周期钩子</h4><ul><li>beforeCreate  实例创建前</li><li>created   已被创建</li><li>beforeMount   dom挂载前</li><li>mounted 已挂载  可以获取dom结点</li><li>beforeUpdate  有数据更新前</li><li>updated  已更新</li><li>beforeDestory  摧毁前</li><li>destoryed  被摧毁</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在现代前端单页面应用中，路由已经变得越来越必不可少。路由描述了url和UI之间的映射关系，这种映射是单向的，即url的变化引发UI的变化。&lt;/p&gt;
&lt;h4 id=&quot;如何实现前端路由&quot;&gt;&lt;a href=&quot;#如何实现前端路由&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="js常见问题" scheme="http://webbHou.github.io/categories/js%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>webpack打包原理和机制</title>
    <link href="http://webbHou.github.io/2019/05/08/webpack%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86%E5%92%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://webbHou.github.io/2019/05/08/webpack打包原理和机制/</id>
    <published>2019-05-08T11:48:20.000Z</published>
    <updated>2021-07-14T02:55:38.236Z</updated>
    
    <content type="html"><![CDATA[<p>  在前端模块化和工程化的演变进程中，涌现出了大量模块化规范和工程化工具，这些规范和工具使我们在编码中更规范，提升了我们代码的复用率，使我们的开发效率和编码得到提高，大大解放了我们的生产力，不需要我们去手动引入模块。</p><h4 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h4><ul><li>CMD规范：module.export | require 同步</li><li>Sea.js：类似于CMD规范</li><li>AMD规范：define | require 异步模块规范</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数是该模块依赖的其他模块  第二参数是一个函数 参数是依赖模块的默认导出成员 里边定义了这个模块实现的功能和方法</span></span><br><span class="line">define([<span class="string">'jquery'</span>,<span class="string">'./module.js'</span>],($,module2)=&gt;&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;  <span class="comment">// return 出的东西就是该模块的导出成员</span></span><br><span class="line">    start: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      $(<span class="string">'body'</span>).text(<span class="string">'111'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个参数是该模块引入的其他模块 第一个参数可以对依赖模块进行使用</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'./module1.js'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">module1</span>)</span>&#123;</span><br><span class="line">  module1.start();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>Es6模块化：export | import</li></ul><h4 id="工程化工具"><a href="#工程化工具" class="headerlink" title="工程化工具"></a>工程化工具</h4><ul><li>Grunt：构建工具 同步 不够灵活</li><li>npm | bower：包管理工具</li><li>Gulp：自动化构建工具 异步 管道式处理 更快</li><li><p>webpack：静态资源打包工具</p><p><strong>在当前前端市场，由于webpack功能的强大和全面，已经在市场上占据了大量的用户，所以本文主要简析webpack</strong></p></li></ul><h4 id="wbepack的几大核心板块"><a href="#wbepack的几大核心板块" class="headerlink" title="wbepack的几大核心板块"></a>wbepack的几大核心板块</h4><ul><li>entry：打包的入口文件，对应用的模块依赖关系做了指示，作为应用构建的开始  默认为’./src/index.js’ 可自定义一个或多个入口</li><li>output：打包的出口，即打包后的文件位置及文件名，path：打包后存放的文件夹路径，filename：打包后的文件名</li><li>loader： 由于webpack只能识别js|json文件，所以需要loader对静态资源文件进行计算处理，根据不同类型文件，使用不同loader并打包成可用的模块，相当于处理器</li><li>plugin：plugin相对于loader更加强大，打包优化(压缩，提取公共，预加载等)，资源的管理(html注入打包后module)，环境变量管理(开发和生产环境)</li><li>mode：设置当前环境模式来做不同处理（development，production，none）</li></ul><h4 id="webpack打包原理"><a href="#webpack打包原理" class="headerlink" title="webpack打包原理"></a>webpack打包原理</h4><ul><li>从打包入口进入，把所有依赖的模块按依赖顺序放入一个空数组中</li><li>把该数组传入一个自执行函数中，该函数被html引入，当页面在浏览器中打开时被执行</li><li>执行第一个模块即入口模块，然后根据入口模块所依赖模块的数组索引找到依赖模块引入</li><li>所有模块被打包进数组时，接受一个module和require方法，module.export对外暴露自己，require用来按索引引入所需模块</li><li>这样按照每个模块的依赖关系来构建起整个应用</li></ul><h5 id="loader原理和实现"><a href="#loader原理和实现" class="headerlink" title="loader原理和实现"></a>loader原理和实现</h5><p>Loader 机制是 Webpack 最核心的机制，因为正是有了 Loader 机制，Webpack 才能足以支撑整个前端项目模块化的大梁，实现通过 Webpack 去加载任何你想要加载的资源。<strong>每一个loader都是一个函数，接收的是需要处理的资源文件内容，输出的是处理完的结果。</strong></p><p>  <strong>webpack的每一个资源处理完后都必须是js的代码格式，因为webpack只能按照JavaScript的语法解析模块。所以使用管道流的方式去处理文件最后生成js code。</strong></p><p>  any source -&gt; loader1 -&gt; loader2 -&gt; javascript</p><p>  其实管道的思想很多地方都在使用，gulp、redux中间件、express中间件、rxjs等。</p><p>  而为什么我们需要把所有的资源引入到js中呢，webpack的设计思想是：<br>    1.方便维护，当一个模块不需要时我们只需要去取这个模块，而不需要再去html去删除相关的引入资源。<br>    2.webpack以js作为入口文件，去按依赖进行模块的引用，所有不会导致资源的遗漏和缺失。</p><p>  下面来具体实现一个loader：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//markdown-loader.js</span></span><br><span class="line"><span class="keyword">const</span> marked = <span class="built_in">require</span>(<span class="string">'marked'</span>)</span><br><span class="line">moudule.export = <span class="function"><span class="params">source</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//具体的loader实现</span></span><br><span class="line">  <span class="keyword">const</span> html = marked(source)</span><br><span class="line">  <span class="comment">//将 html 字符串拼接为一段导出字符串的 JS 代码</span></span><br><span class="line">  <span class="keyword">const</span> code = <span class="string">`module.exports = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(html)&#125;</span>`</span></span><br><span class="line">  <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.md$/</span>,</span><br><span class="line">        <span class="comment">// 直接使用相对路径</span></span><br><span class="line">        use: <span class="string">'./markdown-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="plugin原理和实现"><a href="#plugin原理和实现" class="headerlink" title="plugin原理和实现"></a>plugin原理和实现</h5><p><strong>Webpack 插件机制的目的是为了增强 Webpack 在项目自动化构建方面的能力。</strong></p><p>我在这里先介绍几个插件最常见的应用场景：</p><ul><li><p>实现自动在打包之前清除 dist 目录（上次的打包结果）；</p></li><li><p>自动生成应用所需要的 HTML 文件；</p></li><li><p>根据不同环境为代码注入类似 API 地址这种可能变化的部分；</p></li><li><p>拷贝不需要参与打包的资源文件到输出目录；</p></li><li><p>压缩 Webpack 打包完成后输出的文件；</p></li><li><p>自动发布打包结果到服务器实现自动部署。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">'copy-webpack-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(), <span class="comment">//清楚dist目录 避免缓存</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">'Webpack Plugin Sample'</span>, <span class="comment">//模板需要的title参数</span></span><br><span class="line">      template: <span class="string">'./src/index.html'</span> <span class="comment">//自定义模板 然后去进行生成</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CopyWebpackPlugin(&#123;</span><br><span class="line">      patterns: [<span class="string">'public'</span>] <span class="comment">// 需要拷贝的目录或者路径通配符</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="plugin实现"><a href="#plugin实现" class="headerlink" title="plugin实现"></a>plugin实现</h5><p><strong>Webpack 要求我们的插件必须是一个函数或者是一个包含 apply 方法的类，这个方法接收compiler 对象参数，这个对象是 Webpack 工作过程中最核心的对象，包含所有配置信息。我们运用这个对象去把函数挂载到哪个钩子上。</strong></p><p>webpack钩子：</p><ul><li>emit：Webpack 即将向输出目录输出文件时执行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./remove-comments-plugin.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveCommentsPlugin</span> </span>&#123;</span><br><span class="line">  apply (compiler) &#123;</span><br><span class="line">    <span class="comment">//把这个插件挂载到emit钩子上</span></span><br><span class="line">    compiler.hooks.emit.tap(<span class="string">'RemoveCommentsPlugin'</span>, compilation =&gt; &#123;</span><br><span class="line">      <span class="comment">// compilation =&gt; 可以理解为此次打包的上下文</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> compilation.assets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.endsWith(<span class="string">'.js'</span>)) &#123;</span><br><span class="line">          <span class="keyword">const</span> contents = compilation.assets[name].source() <span class="comment">//文件内容</span></span><br><span class="line">          <span class="keyword">const</span> noComments = contents.replace(<span class="regexp">/\/\*&#123;2,&#125;\/\s?/g</span>, <span class="string">''</span>) <span class="comment">//去除注释文件</span></span><br><span class="line">          compilation.assets[name] = &#123;  <span class="comment">//webapck插件规定的格式</span></span><br><span class="line">            source: <span class="function"><span class="params">()</span> =&gt;</span> noComments,</span><br><span class="line">            size: <span class="function"><span class="params">()</span> =&gt;</span> noComments.length</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心原理和机制"><a href="#核心原理和机制" class="headerlink" title="核心原理和机制"></a>核心原理和机制</h3><ul><li><p>模块化打包：从入口文件开始，根据依赖关系，把整个项目中用到的资源进行一个梳理，形成一个依赖关系树。然后遍历整个树，根据树的依赖关系，把整个项目中散落的js、css、img、font等各种资源文件进行加载，根据配置找到每个资源对应的loader去处理这个模块，把打包结果放入bundle.js中，然后就可以完成整个项目的打包。插件机制是Webpack 打包功能以外的能力，你可以通过钩子在打包的任意环节插入你想要处理的任务。</p></li><li><p>机制：</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  在前端模块化和工程化的演变进程中，涌现出了大量模块化规范和工程化工具，这些规范和工具使我们在编码中更规范，提升了我们代码的复用率，使我们的开发效率和编码得到提高，大大解放了我们的生产力，不需要我们去手动引入模块。&lt;/p&gt;
&lt;h4 id=&quot;模块化规范&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="js常见问题" scheme="http://webbHou.github.io/categories/js%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
      <category term="webpack" scheme="http://webbHou.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>多参数函数的柯里化实现</title>
    <link href="http://webbHou.github.io/2019/04/02/%E5%A4%9A%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96%E5%AE%9E%E7%8E%B0/"/>
    <id>http://webbHou.github.io/2019/04/02/多参数函数的柯里化实现/</id>
    <published>2019-04-02T09:55:50.000Z</published>
    <updated>2021-05-21T09:04:55.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么需要柯里化"><a href="#为什么需要柯里化" class="headerlink" title="为什么需要柯里化"></a>为什么需要柯里化</h3><p>**函数的柯里化就是把多个参数的函数转化为每次调用接受单一参数的函数。使得某些重复的固定的调用和参数可以进行二次封装，从而实现代码的复用，这也是函数式编程的核心思想。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//加法的柯里化实现</span><br><span class="line"><span class="keyword">function</span> thunk(fn)&#123;</span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var args = Array.prototype.slice.call(arguments);</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span>(call)&#123;</span><br><span class="line">      var arument = argus.push(call);</span><br><span class="line">      fn.apply(this,arument);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> add(a,b)&#123;</span><br><span class="line">  <span class="built_in">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">var newAdd = thunk(add);</span><br><span class="line"></span><br><span class="line">newAdd(3)(5)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;为什么需要柯里化&quot;&gt;&lt;a href=&quot;#为什么需要柯里化&quot; class=&quot;headerlink&quot; title=&quot;为什么需要柯里化&quot;&gt;&lt;/a&gt;为什么需要柯里化&lt;/h3&gt;&lt;p&gt;**函数的柯里化就是把多个参数的函数转化为每次调用接受单一参数的函数。使得某些重复的固定的调
      
    
    </summary>
    
      <category term="学习" scheme="http://webbHou.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="javascript" scheme="http://webbHou.github.io/tags/javascript/"/>
    
  </entry>
  
</feed>
