---
title: 深拷贝与浅拷贝
tags:
  - javascript
categories: js常见问题
date: 2018-12-18 11:26:06
---



### 什么情况下用到深拷贝和浅拷贝？

当对象是引用类型时，直接赋值会导致赋值的对象和被赋值的对象指向同一个引用，一个改变另一个也会改变，有时候不注意会导致代码的灾难性。所以我们需要通过深拷贝或浅拷贝来解决。

### 浅拷贝

**浅拷贝**字面意思，只进行浅显的拷贝，也就是这对引用对象的第一次进行拷贝，大多数情况下都可以解决上述问题。

**Object.assign**
```bash
let a = { age: 1 }
let b = Object.assign({}, a)
a.age = 2
console.log(b.age) // 1
```

**ES6展开符**
```bash 
let a = { age: 1 }
let b = {...a}
a.age = 2
console.log(b.age) // 1
```

**但当遇到以下情况就需要用到神拷贝了
```bash 
let a = { age: 1,name:{ firstName:'webbhou' } }
let b = {...a}
a.name.firstName = 'hou'
console.log(name.firstName) // hou
```

### 深拷贝

**Json.parse(Json.stringify(obj))**
```bash
let a = {
  age: 1,
  jobs: {
      first: 'FE'
  }
}
let b = JSON.parse(JSON.stringify(a))
a.jobs.first = 'native'
console.log(b.jobs.first) // FE
```

**缺点**

```bash
let a = {
    age: undefined,
    sex: Symbol('male'),
    jobs: function() {},
    name: 'yck'
}
let b = JSON.parse(JSON.stringify(a))
console.log(b) // {name: "yck"}  会忽略 undefined symbol 不能序列化函数
```
```bash
let obj = {
  a: 1,
  b: {
    c: 2,
    d: 3,
  },
}
obj.c = obj.b
obj.e = obj.a
obj.b.c = obj.c
obj.b.d = obj.b
obj.b.e = obj.b.c
let newObj = JSON.parse(JSON.stringify(obj))
console.log(newObj) //error  不能解决循环引用的对象
```

**递归拷贝**

```bash
function deepClone(obj){
    let objClone = Array.isArray(obj)?[]:{};
    if(obj && typeof obj==="object"){
        for(key in obj){
            if(obj.hasOwnProperty(key)){
                //判断ojb子元素是否为对象，如果是，递归复制
                if(obj[key]&&typeof obj[key] ==="object"){
                    objClone[key] = deepClone(obj[key]);
                }else{
                    //如果不是，简单复制
                    objClone[key] = obj[key];
                }
            }
        }
    }
    return objClone;
}  
let a = {
    age: undefined,
    sex: Symbol('male'),
    jobs: function() {},
    name: 'yck'
}
console.log(deepClone(a))  //{ age: undefined,sex: Symbol('male'),jobs: function() {},name: 'yck' }
```