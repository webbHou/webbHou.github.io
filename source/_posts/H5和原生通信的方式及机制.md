---
title: H5和原生通信的方式及机制
tags:
  - javascript
categories: js常见问题
date: 2021-10-14 16:04:23
---

##### H5和原生通信的几种方式

- 注入API: 原生App通过WebView提供的接口，把通信的方法等注入到JavaScript的window对象中，供JavaScript调用，实现通信。

```javascript
// ios UIWebView
window.postBridgeMessage("参数") 
// ios WKWebView
window.webkit.messageHandlers.execute.postMessage("参数") //execute：原生定义方法
```

- 拦截Scheme：
  **URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的url近似，主要区别是protocol和host一般是自定义的。**
  Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。

```javascript
baidu://hy/action?arg=1&callback=fn //protocol 是 baidu host 则是 hy。
```

Native接收原生消息流程：接收到 JavaScript 消息 => 解析参数，拿到 bridgeName、data 和 callbackId => 根据 bridgeName 找到功能方法，以 data 为参数执行 => 执行返回值和 callbackId 一起回传前端。

##### Native 调用 JavaScript 的方式

Native 调用 JavaScript 较为简单，直接执行拼接好的JavaScript代码即可。需要调用JavaScript的方法注入在全局的window上。

##### JSBridge 的引用方式

- JavaScript端注入: 存在于前端，可直接执行
- 原生端注入：注入方式和 Native 调用 JavaScript 类似，直接执行桥的全部代码，注入时机不缺点，有可能调用时未注入。

##### JSBridge 封装实现

```javascript
const bridge = {
  // 前端调用
  invoke: (bridgeName,data, callback) => {
    const fnID = getId(); //唯一值
    window.[fnID] = callback
    //句柄解析  bridgeName 原生定义方法
    window.webkit.messageHandlers.[bridgeName].postMessage({ data, callback: fnID })
  },
  // 原生接收
  receive: ({ data, callback }) => {
    // 执行bridgeName方法
    // callback(bridgeName执行结果)
  }
}
```
