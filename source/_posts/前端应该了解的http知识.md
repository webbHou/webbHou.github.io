---
title: 前端应该了解的http知识
tags:
  - 计算机基础
categories: 学习
date: 2020-04-10 17:58:41
---

##### 协议：数据传输格式的规范

##### http协议：超文本传输协议，无状态协议，没有记忆功能，属于应用层

#### Tcp协议

* http的底层协议，属于传输层，跟http一样是无连接协议，将两端连接起来，实际上只是两端维护了一个状态。
* 全双工协议，需要确保双方都能接受和发送数据，所以需要三次握手和四次挥手。
* 连接中任意一方掉线都会重新开始连接，一般会重连5次。这也是它是无状态的原因。

#### 简单请求和非简单请求

**非简单请求会在真正请求前发送一个预检请求，options，以获知服务器是否允许该实际请求。**但会浪费时间和性能，所以需要减少和避免。

###### 以下为非简单请求

* 请求方式不属于GET、POST、HEAD
* 不得人为设置其他首部字段
* Content-type值不属于：application/x-www-form-urlencoded、multipart/form-data、text/plain

#### http的general header

* Request URL：请求资源地址
* Request Method: GET
* Status Code: 状态码

#### http请求格式

* 请求头：
  * Accept-Encoding: 可以兼容的压缩格式
  * host：请求主机
  * origin：请求源，可以用于服务端设置请求白名单
  * Referer：请求页的地址
  * Accept-language：请求目标语言
  * user-agent：浏览器的版本和客户端系统
  * content-type：post请求独有的请求头

* 请求体：
  * post：独有的请求体
  * get：拼接在地址栏中

#### http响应格式

* 响应头：
  * Access-Control-Allow-Methods: 允许的请求方式
  * Access-Control-Allow-Origin: 允许的请求源
  * Content-Type: 响应体文档类型和编码格式
  * Date: 时间
  * ETag: 文件唯一标识
  * cache-control: 最大缓存过期时间（秒）
  * expires：缓存过期时间（date格式）
  * Last-Modified：最后一次文件修改时间
  * content-encoding： 压缩格式

* 响应体

#### TLS协议

* 位于传输层和应用层之间，

#### 进程和线程

* 进程：一个进程下可能有多个线程，线程运行与进程之下，不能单独存在 不用进程之间数据很难共享 也不会相互影响 进程需要的资源由计算机系统分配
* 线程：线程之间共享同一个进程的资源，一个线程挂掉会导致整个进程挂掉。进程使用的内存可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。

做个简单的比喻：进程=火车，线程=车厢线程在进程下行进（单纯的车厢无法运行）一个进程可以包含多个线程（一辆火车可以有多个车厢）不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”

#### keep-alive和多路复用

* keep-alive: http1.0之前，每次请求都会有创建Tcp连接，三次握手，服务器响应和断开连接四个过程，当请求数变多时就会导致性能被极大的浪费，所有1.0引入了keep-alive(长连接)，1.0需要手动开启，1,1是默认开启的，长连接每次请求后不立即断开连接，会有一个延时等待时间，这期间同一客户端向服务器发送请求都会复用该 TCP 连接，接着重置延时等待时间，这样大大的节省了重复连接和断开的损耗。  

```bash
timeout 时间到了之后，TCP会立即断开连接吗？
若两小时（timeout）没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔 75 秒发送一次。若一连发送 10 个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。
```

* 那为什么要引入多路复用呢？

* keep-alive依赖于上一次请求的响应，如果上一次请求被阻塞就会导致，整个后边的请求都会被阻塞。
* 人们采取了很多方法去解决，只是通过减少请求数的方式去进行优化。将同一个请求分散到不同域名下，开启了多个 TCP 连接，或者合并请求。例如使用多个域名、引入雪碧图、将小图内联等，但都没有从根本上解决问题。

* 多路复用

* 2.0提出了多路复用的机制，引入了帧和流，因为 **HTTP/1.x 是基于文本的，因为是文本，就导致了它必须是个整体，在传输是不可切割的，只能整体去传**。
* HTTP/2 是基于二进制流的，它就可以把 HTTP 消息分解为独立的帧，交错发送，然后在另一端通过帧中的标识重新组装，这就是多路复用
* 就实现了在同一个TCP连接中，同一时刻可以发送多个请求和响应，且不用按照顺序一一对应，即使某个请求任务耗时严重，也不会影响到其它连接的正常执行
